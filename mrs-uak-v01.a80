;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;				;;
;;    Memory resident system	;;
;;				;;
;;	    Verzia  01		;;
;;				;;
;;	(c) UAK	Bratislava	;;
;;				;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Konverzia: Busy soft 08.10.2024
;
; Zdrojovy text	pre SjASMPlus 1.20.2
;
; Kompilacia vygeneruje	vsetky
; binarky a finalny TAP	subor

    DEFINE tap_file MRS-V01.TAP

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

    DEVICE ZXSPECTRUM48
    ORG	   0

rom_0:		ds 8
rst08:		ds 4Ah			; Basic	error handler
return:		ds 363h			; Tu je	instrukcia RET
sysbep:		ds 111h			; Rutinka BEEP
save_4C6:	ds 9Ch			; Ukladanie na pasku
load_562:	ds 19F2h		; Nacitanie z pasky
brktst:		ds 1CACh		; Rychly test klavesy BREAK
rom_font:	ds 400h			; Znakovy subor
ram:		ds 1C51h		; Zaciatok ramky
rst10_vektor:	ds 2
		ds 78h

; Basic	loader
;
; 10 REM  mrs -	program	nahrany	8.10.1986
; 20 LOAD ""CODE : LOAD ""CODE
; 30 RANDOMIZE USR 54867
; 40 RANDOMIZE USR 54870

    OUTPUT Basic-loader.bas

basic:		db   0,	10		; Riadok 10
		dw 22h			; Basic	error handler
		db 0EAh	; 		; REM
		db ' mrs - program nahrany 8.10.1986'
		db  0Dh

		db   0,	20		; Riadok 20
		dw 0Ah
		db 0EFh, 22h, 22h,0AFh	; LOAD "" CODE
		db  3Ah	; :
		db 0EFh, 22h, 22h,0AFh	; LOAD "" CODE
		db  0Dh

		db   0,	30		; Riadok 30
		dw 0Eh
		db 0F9h	; 		; RANDOMIZE
		db 0C0h	; 		; USR
		db '54867'
		db  0Eh
		db    0
		db    0
		dw cold_start
		db    0
		db  0Dh

		db   0,	40		; Riadok 40
		dw 0Eh
		db 0F9h	; 		; RANDOMIZE
		db 0C0h	; 		; USR
		db '54870'
		db  0Eh
		db    0
		db    0
		dw warm_start
		db    0
		db  0Dh

    OUTEND

basend:		ds 2DDh

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

    OUTPUT Sysmod-#6000.cod

sysmod:					; Entry	point do skompilovaneho	programu
		jp	return

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

libtop:		dw fremem		; Koniec kniznice a zaciatok volnej pamete
libbeg:		db 'sysmod' ; Zaciatok kniznice a napis "sysmod"
		dw fremem
		dw entpnt		; Pocet	navesti	v sysmode

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

ii:					; Zoznam instrukcii oznacenych ako ilegalne
		halt

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

		db    0,   0,	0,   0,	  0,   0,   0,	 0,   0,   0,	0,   0,	  0,   0,   0
entpnt:		db  12h			; Pocet	navesti	v sysmode
		db 'memory'
memory:		dw fremem		; Koniec kniznice a zaciatok volnej pamete
		db 'memtop'
memtop:		dw 0			; Koniec volnej	pamete a zaciatok zdrojoveho textu
		db 'dcbn  '
		dw dcbn			; Prevod desiatkoveho cisla na 16bit hodnotu
		db 'hxbn  '
		dw hxbn			; Prevod hexadecimalneho cisla na 16bit	hodnotu
		db 'bndc  '
		dw bndc			; Prevod 16bit hodnoty na desiatkove cislo
		db 'bnhx  '
		dw bnhx			; Prevod 8bit hodnoty na hexadecimalne cislo
		db 'clear '
		dw clear		; Zmazanie obrazovky
		db 'inkey '
		dw inkey		; ; Obsluha klavesnice s autorepeatom
		db 'scan  '
		dw scan			; Nacitanie stavu klavesnice
		db 'outchr'
		dw outchr		; Vypis	jedneho	znaku na obrazovku
		db 'cursor'
		dw cursor		; Aktualna pozicia vypisu. Prvy	bajt je	stlpec 0-31, druhy bajt	je riadok 0-23.
		db 'setcrs'
		dw setcrs		; Zmazanie kurzora na starej a zobrazenie na novej pozicii
		db 'invpix'
		dw invpix		; Invertovanie znaku na	obrazovke
		db 'mrs   '
		dw mrs			; Praca	s dialogovym riadkom
		db 'mrs2  '
		dw mrs2			; Oprava textu zadaneho	v module "mrs"
		db 'schent'
		dw schent		; Vyhladanie vstupneho bodu v kniznici
		db 'ii    '
		dw ii			; Zoznam instrukcii oznacenych ako ilegalne
		db 'pntchr'
		dw pntchr		; Vytlacenie jedneho znaku na tlaciaren
		db    0

    OUTEND

fremem:		ds 1
		ds 7438h
ramtop:		ds 1			; Tu konci v pameti zdrojovy text
lastln:		ds 2			; Adresa posledneho riadku v zdrojovom texte
adstab:		ds 2			; Adresa tabulky navesti
lnnumb:		ds 2			; Cislo	aktualneho riadku v zdrojovom texte
curent:		ds 2			; Adresa aktualneho riadku v zdrojovom texte
oldchr:		ds 2			; Miesto pre odlozenie aktualnej polohy	kurzoru
atabr:		ds 2			; Adresa tabulky prikazov dekodovanych pri praci s dialogovym riadkom
anavp:		ds 2			; Navratova adresa pri zavolani	"mrs" aby sa "mrs2" vedel kam sa vratit
leftm1:		ds 1			; Pozicia prveho editovatelneho	znaku za promptom
adzero:		ds 2			; Poloha nuloveho bajtu	za zadanym textom
stack:		ds 2			; Hodnota SP pri spusteni systemu MRS
newpag:		ds 1			; Pocet	riadkov	na jednu stranu	listingu zadany	pomocou	direktivy *p
page:		ds 1			; Pocitadlo pre	pocet riadkov na jednu stranku listingu	(0 = bez stran)

    OUTPUT Maincd-#D500.cod

tmf:		db 'mem full' ; Chybove hlasenia
tioer:		db 'io error'
tbreak:		db 'break   '

cchar:		db  18h			; Ovladacie klavesy pre	editaciu zdrojoveho textu
		dw right		; Editacia zdrojoveho textu - CS+8 - posun vpravo
		db  19h
		dw left			; Editacia zdrojoveho textu - CS+5 - posun vlavo
		db  1Dh
		dw tabr			; Editacia zdrojoveho textu - CS+4 - presun na dalsie pole vpravo
		db  1Eh
		dw tabl			; Editacia zdrojoveho textu - CS+1 - presun na predchadzajuce pole vlavo
		db  14h
		dw endadr		; Editacia zdrojoveho textu - SS+SPACE - skok na posledny znak v poli adresy
		db  12h
		dw insert		; Editacia zdrojoveho textu - GRAPH - insert - vytvorenie miesta pre znak
		db  13h
		dw delete		; Editacia zdrojoveho textu - DELETE - zmazanie	znaku
		db  0Dh
		dw eol			; Editacia zdrojoveho textu - ENTER - vytvorenie noveho	prazdneho riadku pod aktualnym
		db    7
		dw delln		; Editacia zdrojoveho textu - SS+CS - Zmazanie aktualneho riadku
		db  17h
		dw prevln		; Editacia zdrojoveho textu - CS+7 - prechod na	predchadzajuci riadok
		db  1Ah
		dw nextln		; Editacia zdrojoveho textu - CS+6 - skok na nasledujuci riadok
		db  1Ch
		dw previm		; Editacia zdrojoveho textu - CS+2 - skok na nasledujucu stranku
		db  1Fh
		dw nxtvim		; Editacia zdrojoveho textu - CS+3 - skok na nasledujucu stranku
		db  11h
		dw edi			; BREAK	- Ukoncenie editacie zdrojoveho	textu a	skok do	"edi>"
		db    3
		dw homeim		; Editacia zdrojoveho textu - SS+ENTER - obnovenie obrazovky
		db    5
		dw copyln		; Editacia zdrojoveho textu - CS+ENTER - zdvojenie aktualneho riadku

startf:		db 0
startf_1:	db 7
		db 0Ch
		db 20h
		db 40h
newcur:		dw 1700h
aldind:		db 0
ldind:		db 0
insyes:		db 0

ktab0:		db    0			; Tabulka klavesnice - bez shiftu
		db  7Ah	; z
		db  78h	; x
		db  63h	; c
		db  76h	; v
		db  61h	; a
		db  73h	; s
		db  64h	; d
		db  66h	; f
		db  67h	; g
		db  71h	; q
		db  77h	; w
		db  65h	; e
		db  72h	; r
		db  74h	; t
		db  31h	; 1
		db  32h	; 2
		db  33h	; 3
		db  34h	; 4
		db  35h	; 5
		db  30h	; 0
		db  39h	; 9
		db  38h	; 8
		db  37h	; 7
		db  36h	; 6
		db  70h	; p
		db  6Fh	; o
		db  69h	; i
		db  75h	; u
		db  79h	; y
		db  0Dh
		db  6Ch	; l
		db  6Bh	; k
		db  6Ah	; j
		db  68h	; h
		db  20h
		db    0
		db  6Dh	; m
		db  6Eh	; n
ktab1_1:	db  62h	; b

ktab1:		db    0			; Tabulka klavesnice - caps shift
		db  5Ah	; Z
		db  58h	; X
		db  43h	; C
		db  56h	; V
		db  41h	; A
		db  53h	; S
		db  44h	; D
		db  46h	; F
		db  47h	; G
		db  51h	; Q
		db  57h	; W
		db  45h	; E
		db  52h	; R
		db  54h	; T
		db  1Eh			; CS+1 edit
		db  1Fh			; CS+2 caps lock
		db  1Ch			; CS+3 true video
		db  1Dh			; CS+4 inv video
		db  19h			; CS+5 vlavo
		db  13h			; CS+0 delete
		db  12h			; CS+9 graph
		db  18h			; CS+8 vpravo
		db  17h			; CS+7 hore
		db  1Ah			; CS+6 dole
		db  50h	; P
		db  4Fh	; O
		db  49h	; I
		db  55h	; U
		db  59h	; Y
		db    5			; CS+Enter
		db  4Ch	; L
		db  4Bh	; K
		db  4Ah	; J
		db  48h	; H
		db  11h			; CS+Space
		db    7			; CS+SS	extend mode
		db  4Dh	; M
		db  4Eh	; N
ktab2_1:	db  42h	; B

ktab2:		db    0			; Tabulka klavesnice - symbol shift
		db  3Ah	; :
		db    0
		db  3Fh	; ?
		db  2Fh	; /
		db    0
		db    0
		db    0
		db    0
		db    0
		db    0
		db    0
		db    0
		db  3Ch	; <
		db  3Eh	; >
		db  21h	; !
		db  40h	; @
		db  23h	; #
		db  24h	; $
		db  25h	; %
		db  5Fh	; _
		db  29h	; )
		db  28h	; (
		db  27h	; '
		db  26h	; &
		db  22h	; "
		db  3Bh	; ;
		db    0
		db    0
		db    0
		db    3
		db  3Dh	; =
		db  2Bh	; +
		db  2Dh	; -
		db  5Eh	; ^
		db  14h
		db    0
		db  2Eh	; .
		db  2Ch	; ,
		db  2Ah	; *

tedi:		db 'edi>'      ; Prompt modulu "edi>"
cedi:		db 'mer'          ; Prikazy modulu "edi>"
		dw mertxt		; Prikaz edi>mer - prihratie noveho zdrojoveho textu do	stareho
		db 'sav'
		dw savtxt		; Prikaz edi>sav - ulozenie zdrojoveho textu
		db 'loa'
		dw loatxt		; Prikaz edi>loa - nahratie zdrojoveho textu
		db 'dis'
		dw dis			; Prikaz edi>dis - spetny prekladac strojoveho kodu do zdrojoveho textu
		db 'ins'
		dw instxt		; Prikaz edi>ins - moznost pluginu pre vytvaranie zdrojoveho textu
		db 'ini'
		dw begedi		; Prikaz edi>ini - Inicializacia zdrojaku a start celoobrazovkoveho editora
		db 'ln='
		dw lclneq		; Prikaz edi>ln= - skok	na dane	miesto zdrojoveho textu
		db 'ln+'
		dw lclnpl		; Prikaz edi>ln+ - skok	o dany pocet riadkov v zdrojovom texte dopredu
		db 'ln-'
		dw lclnmi		; Prikaz edi>ln- - skok	o dany pocet riadkov v zdrojovom texte nazad
		db 'dlb'
		dw delblk		; Prikaz edi>dlb - Zmazanie casti zdrojoveho textu
		db 'cpb'
		dw cpyblk		; Prikaz edi>dlb - Skopirovanie	casti zdrojoveho textu
		db 0FFh

tmonit:		db 'mrs>'      ; Prompt modulu "mrs>"
cmonit:		db 'edi'          ; Prikazy modulu "mrs>"
		dw edi			; Prikaz mrs>edi - skok	do modulu edi>
		db 'asm'
		dw asm			; Prikaz mrs>asm - preklad zdrojoveho textu
		db 'dbg'
		dw dbg			; Prikaz mrs>dbg - spustenie debuggera
		db 'lnk'
		dw lnk			; Prikaz mrs>lnk - linkovanie zdrojoveho textu
		db 'lib'
		dw lib			; Prikaz mrs>lib - skok	do modulu lib>
		db 'ald'
		dw ald			; Prikaz mrs>ald - Preklad a linkovanie	zdrojoveho textu a potom skok do debuggera
		db 'mon'
		dw exit			; Prikaz mrs>mon - ukoncenie MRS a navrat do basicu
		db 'run'
		dw run			; Prikaz mrs>run - spustenie skompilovaneho programu od	jeho entry pointu
		db    0

cright:		db 'program zadarmo ' ; Copyright
		db 7Fh
		db ' UAK Bratislava'

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Studeny start	MRS po nahradi do pameti
; Inicializuje a zmaze zdrojovy	text

cold_start:				; Vymazanie celeho zdrojoveho textu a tabulky navesti
		call	inival

; Teply	start MRS
; Nemaze zdrojovy text

warm_start:
		di
		ld	sp, stack_init
		call	clear		; Zmazanie obrazovky
		call	bbc		; Zmazanie casti buffera pre cislo editovaneho riadku
		ld	(stack), sp	; Hodnota SP pri spusteni systemu MRS
		ld	hl, 2027h
		ld	(sent),	hl
		ld	hl, 5800h
		ld	(poscur), hl	; Aktualna pohoha blikajuceho atributu na obrazovke
		ld	h, 0
		ld	(krept), hl

;;;;;;;;;;;;;;;;;;;;
;;		  ;;
;;  Modul "mrs>"  ;;
;;		  ;;
;;;;;;;;;;;;;;;;;;;;

monit:					; Vstup	do modulu "mrs>"
		ld	hl, 50E0h
		ld	de, cright	; Copyright
		call	loutb		; Vypis	zadaneho textu a zmazanie kurzora
		ld	h, 3
		call	wmg		; Chvilka cakania
		ld	hl, tmonit	; Prompt modulu	"mrs>"
		ld	de, cmonit	; Prikazy modulu "mrs>"

ctrl:
		ld	bc, 401h
		call	mrs_x		; Dialogovy riadok a biely border
		jp	(hl)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

run:					; Prikaz mrs>run - spustenie skompilovaneho programu od	jeho entry pointu
		call	getend
		dec	de
		ld	(memtop), de	; Koniec volnej	pamete a zaciatok zdrojoveho textu
		call	sysmod		; Entry	point do skompilovaneho	programu
		jr	monit		; Vstup	do modulu "mrs>"

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;
;;		  ;;
;;  Modul "edi>"  ;;
;;		  ;;
;;;;;;;;;;;;;;;;;;;;

edi:					; Prikaz mrs>edi - skok	do modulu edi>
		xor	a
		ld	(ldind), a
		ld	(insyes), a
		ld	hl, tedi	; Prompt modulu	"edi>"
		ld	de, cedi	; Prikazy modulu "edi>"
		jp	ctrl

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

inival:					; Vymazanie celeho zdrojoveho textu a tabulky navesti
		call	slnini
		ld	(lastln), hl	; Adresa posledneho riadku v zdrojovom texte
		ld	(hl), a
		dec	hl
		ld	(adstab), hl	; Adresa tabulky navesti
		ld	(hl), a
		ld	h, a
		ld	l, a
		ld	(cursor), hl	; Aktualna pozicia vypisu. Prvy	bajt je	stlpec 0-31, druhy bajt	je riadok 0-23.
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Navrat do basicu

exit:					; Prikaz mrs>mon - ukoncenie MRS a navrat do basicu
		ld	iy, 5C3Ah
		ei
		rst	8		; Basic	error handler

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

		db 0FFh			; Hlasenie "OK"

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

begedi:					; Prikaz edi>ini - Inicializacia zdrojaku a start celoobrazovkoveho editora
		call	clear
		call	inival		; Vymazanie celeho zdrojoveho textu a tabulky navesti
		jr	edit2

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

edit0:					; Vyraznejsi zvukovy signal so zachovanim AF
		call	beep

edit1:
		ld	a, (insyes)
		or	a
		call	z, unpln0	; Nacita a depakuje aktualny riadok zdrojoveho textu do	textoveho buffera
		jr	z, edit3
		call	iinsln		; Posun	obrazovky smerom dole

edit2:					; Zmazanie textoveho buffera
		call	blank

edit3:
		xor	a
		ld	(newcur), a
		ld	l, a
		call	wlnnum		; Vypis	cisla editovaneho riadku vpravo	dole
		ld	a, 9		; ed3_jmp - ed3	- 2

wrrow1:
		ld	(ed3+1), a

wrrow:
		ld	a, (row)
		ld	h, a
		call	setcrs		; Zmazanie kurzora na starej a zobrazenie na novej pozicii
		call	outbf0		; Vypis	textoveho buffera na riadok obrazovky dany kurzorom
		ld	h, 0FEh	; ''
		call	inkey		; ; Obsluha klavesnice s autorepeatom
		ld	de, wrrow
		push	de
		ld	b, a
		cp	80h ; ''
		jr	nc, ctrlch
		cp	20h ; ' '
		jp	nc, ascii

ctrlch:
		push	hl
		ld	bc, 3
		ld	de, 1007h
		ld	hl, cchar	; Ovladacie klavesy pre	editaciu zdrojoveho textu

ed1a:
		cp	(hl)
		jr	z, ed2
		add	hl, bc
		dec	e
		dec	d
		jr	nz, ed1a

ed2:
		inc	hl
		ld	c, (hl)
		inc	hl
		ld	b, (hl)
		pop	hl
		dec	e
		push	bc
		ret	p
		pop	bc
		pop	af

ed3:
		jr	$

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

		ld	a, d
		sub	9
		jr	nz, cherr
		ld	(newcur), a
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

ed3_jmp:
		dec	d
		jp	m, cherr
		ld	a, d
		cp	7
		push	bc
		ret	z
		call	chblk		; Hladanie konca textu v textovom bufferi
		jr	nz, ed4
		ld	hl, (curent)	; Adresa aktualneho riadku v zdrojovom texte
		ld	a, (hl)
		or	a

ed4:
		call	nz, pln
		jr	z, ed5

cherr0:
		ld	l, a
		pop	af

cherr:					; Vyraznejsi zvukovy signal so zachovanim AF
		call	beep
		jp	wrrow

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

ed5:
		ld	(insyes), a
		inc	a
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

pln:					; Spakovanie textoveho riadku do formatu zdrojoveho textu
		call	packln
		ret	nz
		ld	hl, pdline	; Buffer pre spakovany riadok zdrojoveho textu
		bit	7, (hl)
		dec	hl
		jr	nz, pc0
		ld	a, (hl)
		sub	0Dh
		jr	nz, pc0_1
		cp	(hl)
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

pc0:
		dec	hl

pc0_1:
		ld	a, (hl)
		rra
		jr	c, pc3
		and	70h ; 'p'
		jr	z, pc3
		dec	hl
		jp	po, pc2
		ld	a, (hl)
		and	7

pc1:
		cp	6
		ld	a, 0Ch
		ret	nz
		jr	pc3

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

pc2:
		cp	10h
		jr	z, pc3
		ld	a, (hl)
		cp	0EBh ; ''
		jr	z, pc1

pc3:					; Overenie ci je medzi koncom kniznice a zaciatkom zdrojoveho textu aspon 64 bajtov miesta
		call	tstend
		jp	nc, wtmf	; Chybove hlasenie "MEM FULL"
		ld	de, buffer	; Textovy buffer pre jeden riadok na obrazovke
		ld	bc, 40h	; '@'
		ex	de, hl
		ldir
		push	de
		ld	hl, pdline	; Buffer pre spakovany riadok zdrojoveho textu
		call	unpln		; Nacita a depakuje riadok zdrojoveho textu do textoveho buffera
		pop	de
		ld	hl, buffer_end

pc4:
		dec	de
		ld	a, (de)
		cp	(hl)
		ld	a, l

rnznop:
		ret	nz
		dec	l
		jp	p, pc4
		ld	a, (insyes)
		or	a
		jr	nz, rw2
		ld	hl, (curent)	; Adresa aktualneho riadku v zdrojovom texte
		or	(hl)
		jr	z, rw2
		ld	de, pdline	; Buffer pre spakovany riadok zdrojoveho textu
		ld	a, (de)
		and	7Fh ; ''
		ld	c, a

rw1:
		dec	c
		jp	m, rw3
		ld	a, (de)
		cp	(hl)
		dec	hl
		dec	de
		jr	z, rw1
		call	mdelln		; Zmazanie aktualneho riadku v zdrojovom texte

rw2:					; Vlozenie noveho riadku do zdrojoveho textu
		call	minsln

rw3:					; Aktualna pozicia vypisu. Prvy	bajt je	stlpec 0-31, druhy bajt	je riadok 0-23.
		ld	hl, (cursor)
		ld	a, 1Fh
		cp	l
		ld	l, 0
		call	c, outbuf	; Vypis	textoveho buffera na dany riadok obrazovky
		xor	a
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

outln:					; Nacita, depakuje a vypise aktualny riadok zdrojoveho textu
		push	de
		call	unpln0		; Nacita a depakuje aktualny riadok zdrojoveho textu do	textoveho buffera
		pop	de

outbf0:					; Vypis	textoveho buffera na riadok obrazovky dany kurzorom
		ld	hl, (cursor)

outbuf:					; Vypis	textoveho buffera na dany riadok obrazovky
		push	bc
		push	de
		push	hl
		ld	d, 0FEh	; ''
		ld	a, l
		ld	l, 20h ; ' '
		cp	l
		dec	l
		ld	e, l
		jr	c, ob1
		ld	e, a

ob1:
		ld	a, (de)
		push	hl
		call	setch0		; Vykreslenie jedneho znaku na obrazovku (A = ascii kod, H = riadok, L = stlpec)
		pop	hl
		dec	e
		dec	l
		jp	p, ob1
		pop	hl
		pop	de
		pop	bc
		xor	a
		inc	a

expnt:
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

tstend:					; Overenie ci je medzi koncom kniznice a zaciatkom zdrojoveho textu aspon 64 bajtov miesta
		call	getend
		ld	hl, -40h
		add	hl, de
		ld	de, (libtop)	; Koniec kniznice a zaciatok volnej pamete
		ld	a, e
		sub	l
		ld	a, d
		sbc	a, h
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

abscps:					; Prepocet riadku v H (0-23) a stlpca v	L (0-31) na adresu vo videoramke
		ld	a, h
		rrca
		rrca
		rrca
		and	0E0h ; ''
		or	l
		ld	l, a
		ld	a, h
		and	18h
		or	40h ; '@'
		ld	h, a
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

setchr:					; Vykreslenie jedneho znaku na aktualnu	poziciu	podla kurzora
		ld	hl, (cursor)

setch0:					; Vykreslenie jedneho znaku na obrazovku (A = ascii kod, H = riadok, L = stlpec)
		push	af
		call	abscps		; Prepocet riadku v H (0-23) a stlpca v	L (0-31) na adresu vo videoramke
		pop	af

pixel:					; Vykreslenie jedneho znaku na obrazovku (A = ascii kod, DE = pozicia vo videoram)
		push	hl
		push	de
		push	bc
		ex	de, hl
		ld	l, a
		ld	h, 0
		add	hl, hl
		add	hl, hl
		add	hl, hl
		ld	bc, rom_font	; Znakovy subor
		add	hl, bc
		ld	b, 8

px1:
		ld	a, (hl)
		ld	(de), a
		inc	d
		inc	hl
		djnz	px1
		pop	bc
		pop	de
		pop	hl
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;   invpix - invertuje znak obrazovky.
;	     vstup:  <h> - riadok <0-23>
;		     <l> - stlpec <0-31>
;	     vystup:
;	     meni sa:  <af>

invpix:					; Invertovanie znaku na	obrazovke
		push	hl
		push	bc
		call	abscps		; Prepocet riadku v H (0-23) a stlpca v	L (0-31) na adresu vo videoramke
		ld	b, 8

ipx1:
		ld	a, (hl)
		cpl
		ld	(hl), a
		inc	h
		djnz	ipx1
		pop	bc
		pop	hl
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;   setcrs - na	povodnom mieste	sa jazdec (blikajuci stvorcek) zmaze
;	     a na pozicii, ktoru udava premenna	cursor sa objavi.
;	     vstup:  cursor = nova pozicia jazdca
;	     vystup:
;	     meni sa:<af>

setcrs:					; Zmazanie kurzora na starej a zobrazenie na novej pozicii
		push	hl
		ld	hl, (poscur)	; Aktualna pohoha blikajuceho atributu na obrazovke
		res	7, (hl)
		pop	hl
		push	hl
		push	de
		ld	a, l
		cp	20h ; ' '
		jr	c, scr1
		ld	a, 1Fh

scr1:
		ld	d, 58h ; 'X'
		ld	e, a
		ld	l, h
		ld	h, 0
		add	hl, hl
		add	hl, hl
		add	hl, hl
		add	hl, hl
		add	hl, hl
		add	hl, de
		pop	de
		ld	(poscur), hl	; Aktualna pohoha blikajuceho atributu na obrazovke
		set	7, (hl)
		pop	hl
		ld	(cursor), hl	; Aktualna pozicia vypisu. Prvy	bajt je	stlpec 0-31, druhy bajt	je riadok 0-23.
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;   clear  - vymazanie obrazovky.
;	     vstup:
;	     vystup:
;	     meni sa:  vsetko

clear:					; Zmazanie obrazovky
		ld	hl, 4000h
		ld	de, 4001h
		ld	bc, 1800h
		ld	(hl), 0
		ldir
		ld	(poscur), hl	; Aktualna pohoha blikajuceho atributu na obrazovke
		ld	(hl), 38h ; '8'
		ld	bc, 2FFh
		ldir
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

iiid:					; Skopirovanie jedneho textoveho riadku
		push	hl
		push	bc
		ld	a, 8

iid1:
		ld	bc, 20h	; ' '
		push	de
		push	hl
		ldir
		pop	hl
		pop	de
		inc	h
		inc	d
		dec	a
		jr	nz, iid1
		pop	bc
		pop	hl
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

idelln:					; Posun	(casti)	obrazovky smerom hore
		ld	hl, (cursor)

idel:					; Posun	(casti)	obrazovky smerom hore
		sub	h
		ret	z
		ld	b, a
		ld	l, 0
		call	abscps		; Prepocet riadku v H (0-23) a stlpca v	L (0-31) na adresu vo videoramke

ii0:
		ld	d, h
		ld	a, l
		add	a, 20h ; ' '
		ld	e, l
		ld	l, a
		jr	nz, ii1
		ld	a, 8
		add	a, h
		ld	h, a

ii1:					; Skopirovanie jedneho textoveho riadku
		call	iiid
		djnz	ii0
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

iinsln:					; Posun	obrazovky smerom dole
		ld	a, 16h
		ld	hl, (cursor)	; Aktualna pozicia vypisu. Prvy	bajt je	stlpec 0-31, druhy bajt	je riadok 0-23.
		sub	h
		ret	z
		ret	c
		ld	hl, 50A0h
		ld	de, 50C0h
		ld	b, a

id0:					; Skopirovanie jedneho textoveho riadku
		call	iiid
		ex	de, hl
		ld	a, e
		sub	20h ; ' '
		ld	l, a
		ld	h, d
		jr	nc, id1
		ld	a, d
		sub	8
		ld	h, a

id1:
		djnz	id0
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;   scan   - ohmatanie	klavesnice. modul zisti, ci je niektory	klaves stlaceny
;	     vstup:
;	     vystup: <a> = 0 ak	nie je nic stlacene, alebo ak je  slacena
;			     nelegalna kombinacia klaves (napr ss alebo	ss/a)
;	     meni sa:  <af>

scan:					; Nacitanie stavu klavesnice
		push	bc
		ld	bc, 0FEh ; ''
		in	a, (c)
		pop	bc
		cpl
		and	1Fh
		ret	z
		push	bc
		push	de
		push	hl
		ld	bc, 0FEFEh
		ld	hl, 0
		ld	e, 1

ks3:
		in	a, (c)
		ld	d, 5

ks4:
		rrca
		jr	c, ks1
		inc	h
		dec	h
		jr	nz, kerr
		ld	h, l
		ld	l, e

ks1:
		inc	e
		dec	d
		jr	nz, ks4
		rlc	b
		jr	c, ks3
		ex	de, hl
		ld	hl, insyes	; Tabulka klavesnice - bez shiftu
		inc	d
		dec	d
		jr	z, kte
		inc	e
		dec	e
		jr	z, addd
		ld	hl, ktab1_1	; Tabulka klavesnice - caps shift
		ld	a, 1
		cp	d
		jr	z, adde
		cp	e
		jr	z, addd
		ld	hl, ktab2_1	; Tabulka klavesnice - symbol shift
		ld	a, 25h ; '%'
		cp	d
		jr	z, adde
		cp	e
		jr	z, addd

kerr:
		xor	a

kret:
		pop	hl
		pop	de
		pop	bc
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

addd:
		ld	e, d

adde:
		ld	d, 0
		add	hl, de
		ld	a, (hl)
		jr	kret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

kte:
		inc	e
		dec	e
		jr	z, kerr
		jr	adde

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;   inkey  - citanie jedneho znaku z klavesnice	 s  automatickym  opakovanim.
;	     modul  caka,  kym	nie je stlaceny	klaves.	 po opaetovnom volani
;	     vykonava  automaticke  opakovanie,	 teda  podrzanie  klavesu  ma
;	     rovnaky  ucinok  ako jej opaetovne	stlacanie.  stlacenie klavesu
;	     je	indikovane zvukom.
;	     vstup:
;	     vystup: <a> = ascii kod stlacenej klavesy
;	     meni sa:  <af>

inkey:					; ; Obsluha klavesnice s autorepeatom
		push	bc

inkey1:					; Nacitanie stavu klavesnice
		call	scan
		or	a
		jr	nz, in3
		ld	(krept+1), a
		jr	inkey1

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

in3:
		ld	bc, 1000h

wait1:
		dec	c
		jr	nz, wait1
		djnz	wait1
		ld	c, a
		call	scan		; Nacitanie stavu klavesnice
		cp	c
		jr	nz, inkey1
		ld	a, (krept+1)
		cp	c
		jr	z, repeat
		ld	a, 0FAh	; ''
		jr	sin1

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

repeat:
		ld	a, (krept)
		ld	b, a

rep1:
		xor	a

rep2:
		dec	a
		jr	nz, rep2
		call	scan		; Nacitanie stavu klavesnice
		cp	c
		jr	nz, inkey1
		djnz	rep1
		ld	a, 19h

sin1:
		ld	(krept), a
		ld	a, c
		ld	(krept+1), a
		push	af
		or	a
		call	bbeep		; Zvukovy signal (CY=0:kratsi pip, CY=1:dlhsi pip)
		pop	af
		pop	bc
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

scroll:					; Posun	obrazovky smerom hore
		ld	hl, (cursor)

scrol1:					; Posun	obrazovky smerom hore
		ld	a, 17h
		push	hl
		push	de
		ld	hl, 0
		ld	(cursor), hl	; Aktualna pozicia vypisu. Prvy	bajt je	stlpec 0-31, druhy bajt	je riadok 0-23.
		call	idelln		; Posun	(casti)	obrazovky smerom hore
		pop	de
		pop	hl
		ld	(cursor), hl	; Aktualna pozicia vypisu. Prvy	bajt je	stlpec 0-31, druhy bajt	je riadok 0-23.
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

copyln:					; Editacia zdrojoveho textu - CS+ENTER - zdvojenie aktualneho riadku
		call	iinsln
		scf

eol:					; Editacia zdrojoveho textu - ENTER - vytvorenie noveho	prazdneho riadku pod aktualnym
		ld	a, 1
		ld	(insyes), a

nextln:					; Editacia zdrojoveho textu - CS+6 - skok na nasledujuci riadok
		ld	d, a
		ld	hl, edit1
		jr	nc, nl1
		ld	hl, edit3

nl1:
		push	hl

rollup:					; Adresa aktualneho riadku v zdrojovom texte
		ld	hl, (curent)
		call	skln		; Preskoc riadok zdrojoveho textu na ktory ukazuje HL a	nastav sa na dalsi riadok
		jp	z, beep		; Vyraznejsi zvukovy signal so zachovanim AF
		call	outcrl		; Presun kurzora na zaciatok noveho riadku
		ld	a, (insyes)
		or	a
		call	z, outln	; Nacita, depakuje a vypise aktualny riadok zdrojoveho textu
		dec	d
		jr	nz, rollup
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

prevln:					; Editacia zdrojoveho textu - CS+7 - prechod na	predchadzajuci riadok
		ld	hl, edit1
		push	hl

rolldw:					; Cislo	aktualneho riadku v zdrojovom texte
		ld	hl, (lnnumb)
		ex	de, hl
		dec	de
		inc	d
		jp	z, beep		; Vyraznejsi zvukovy signal so zachovanim AF
		dec	d
		call	sline		; Najdi	DE-ty riadok v zdrojovom texte
		ld	hl, row
		dec	(hl)
		ret	p
		inc	(hl)
		call	iinsln		; Posun	obrazovky smerom dole
		jp	outln		; Nacita, depakuje a vypise aktualny riadok zdrojoveho textu

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

lcln1:					; Nacitaj ciselny parameter a dalsiu navratovu adresu natav na potom vstup do editora
		ex	de, hl
		call	dcbn		; Prevod desiatkoveho cisla na 16bit hodnotu
		ld	a, (hl)
		or	a
		jp	nz, mrs3
		ld	a, d
		or	e
		ld	hl, cted	; Vstup	do celoobrazovkoveho editora
		ex	(sp), hl
		jp	(hl)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

lclneq:					; Prikaz edi>ln= - skok	na dane	miesto zdrojoveho textu
		ex	de, hl
		call	getlbl		; Vyhladanie navestia v	tabulke	navesti
		jr	nc, lclnlb
		call	dcbn		; Prevod desiatkoveho cisla na 16bit hodnotu
		ld	a, (hl)
		or	a
		jp	nz, mrs2	; Oprava textu zadaneho	v module "mrs"
		ld	a, d
		or	e
		dec	de
		jp	nz, cted

homeim:					; Editacia zdrojoveho textu - SS+ENTER - obnovenie obrazovky
		ld	hl, (lnnumb)
		ex	de, hl
		jp	cted

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

lclnlb:					; Aktualny riadok zdrojoveho textu bude	prvy (nastavi aj cislo riadku)
		call	slnini
		ld	e, c

llb1:
		ld	a, (hl)
		add	a, a
		jp	z, mrs2		; Oprava textu zadaneho	v module "mrs"
		jr	nc, llb2
		dec	hl
		ld	a, (hl)
		inc	hl
		cp	e
		jp	z, outscr

llb2:					; Preskoc riadok zdrojoveho textu na ktory ukazuje HL a	nastav sa na dalsi riadok
		call	skln
		jr	llb1

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

lclnpl:					; Prikaz edi>ln+ - skok	o dany pocet riadkov v zdrojovom texte dopredu
		call	lcln1
		ld	hl, (lnnumb)	; Cislo	aktualneho riadku v zdrojovom texte
		add	hl, de
		jr	c, llp1
		ex	de, hl
		ret	nz

llp1:
		ld	de, -1
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

lclnmi:					; Prikaz edi>ln- - skok	o dany pocet riadkov v zdrojovom texte nazad
		call	lcln1
		call	neg		; Zneguje hodnotu DE = -DE

imctn:					; Cislo	aktualneho riadku v zdrojovom texte
		ld	hl, (lnnumb)
		add	hl, de
		ex	de, hl
		ret	c
		cp	l
		ret	z
		ld	de, 0
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

previm:					; Editacia zdrojoveho textu - CS+2 - skok na nasledujucu stranku
		scf

nxtvim:					; Editacia zdrojoveho textu - CS+3 - skok na nasledujucu stranku
		sbc	a, a
		ld	d, a
		xor	17h
		sub	d
		ld	hl, row
		sub	(hl)
		ld	e, a
		sub	d
		ld	hl, cted
		push	hl
		jr	imctn

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

slnini:					; Aktualny riadok zdrojoveho textu bude	prvy (nastavi aj cislo riadku)
		xor	a
		ld	h, a
		ld	l, a
		ld	(lnnumb), hl	; Cislo	aktualneho riadku v zdrojovom texte

crtnin:					; Aktualny riadok zdrojoveho textu bude	prvy
		ld	hl, ramtop
		ld	(curent), hl	; Adresa aktualneho riadku v zdrojovom texte
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

sline:					; Najdi	DE-ty riadok v zdrojovom texte
		call	slnini

sl1:
		ld	a, d
		or	e
		ret	z
		call	skln		; Preskoc riadok zdrojoveho textu na ktory ukazuje HL a	nastav sa na dalsi riadok
		ret	z
		dec	de
		jr	sl1

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

cntedi:					; Najdi	posledny riadok	v zdrojovom texte
		call	slln
		ld	d, a
		ld	e, a

cted:					; Najdi	DE-ty riadok v zdrojovom texte
		call	sline

outscr:					; Zmazanie obrazovky
		call	clear
		ld	hl, (lnnumb)	; Cislo	aktualneho riadku v zdrojovom texte
		push	hl
		ld	hl, 0
		ld	(cursor), hl	; Aktualna pozicia vypisu. Prvy	bajt je	stlpec 0-31, druhy bajt	je riadok 0-23.
		push	hl
		ld	hl, (curent)	; Adresa aktualneho riadku v zdrojovom texte
		push	hl
		ld	d, 16h
		call	rollup
		pop	hl
		ld	(curent), hl	; Adresa aktualneho riadku v zdrojovom texte
		pop	hl
		ld	(cursor), hl	; Aktualna pozicia vypisu. Prvy	bajt je	stlpec 0-31, druhy bajt	je riadok 0-23.
		pop	hl
		ld	(lnnumb), hl	; Cislo	aktualneho riadku v zdrojovom texte
		jp	edit1

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

slln0:					; Zrus navratovu adresu	a najdi	posledny riadok	v zdrojovom texte
		pop	de

slln:					; Najdi	posledny riadok	v zdrojovom texte
		ld	de, -1
		call	sline		; Najdi	DE-ty riadok v zdrojovom texte
		ld	(lastln), hl	; Adresa posledneho riadku v zdrojovom texte
		dec	hl
		ld	(adstab), hl	; Adresa tabulky navesti
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

negbc0:					; Vrati	zapornu	dlzku spakovaneho riadku v zdrojovom texte
		ld	a, (hl)

negbc:					; Vrati	zapornu	dlzku spakovaneho riadku v zdrojovom texte
		and	7Fh ; ''
		ld	b, 0FFh
		cpl
		ld	c, a
		inc	bc
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

neg:					; Zneguje hodnotu DE = -DE
		ld	a, e
		cpl
		ld	e, a
		ld	a, d
		cpl
		ld	d, a
		inc	de
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

cmhlde:					; Porovnanie HL	a DE
		ld	a, h
		cp	d
		ret	nz
		ld	a, l
		cp	e
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

skln:					; Preskoc riadok zdrojoveho textu na ktory ukazuje HL a	nastav sa na dalsi riadok
		ld	a, (hl)
		or	a
		ret	z
		push	hl
		ld	hl, (lnnumb)	; Cislo	aktualneho riadku v zdrojovom texte
		inc	hl
		ld	(lnnumb), hl	; Cislo	aktualneho riadku v zdrojovom texte
		pop	hl

skipln:					; Presun na dalsi riadok v zdrojovom texte
		call	negbc0
		add	hl, bc
		ld	(curent), hl	; Adresa aktualneho riadku v zdrojovom texte
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

chblk:					; Hladanie konca textu v textovom bufferi
		ld	b, 40h ; '@'

chblk1:
		ld	l, b

endad1:					; Hladanie konca textu od danej	pozicie
		ld	h, 0FEh	; ''
		ld	a, 20h ; ' '

ea1:
		dec	l
		ret	m
		cp	(hl)
		ret	nz
		dec	b
		jr	nz, ea1
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

mdelln:					; Zmazanie aktualneho riadku v zdrojovom texte
		ld	a, (insyes)
		or	a
		ret	nz
		call	getend		; Zistenie kde v pameti	zacina zdrojovy	text
		call	negbc0		; Vrati	zapornu	dlzku spakovaneho riadku v zdrojovom texte
		ret	z

md1:
		push	hl
		add	hl, bc
		call	cmhlde		; Porovnanie HL	a DE
		ld	a, (hl)
		pop	hl
		ld	(hl), a
		dec	hl
		jr	nz, md1
		ld	hl, (lastln)	; Adresa posledneho riadku v zdrojovom texte
		sbc	hl, bc
		ld	(lastln), hl	; Adresa posledneho riadku v zdrojovom texte
		dec	hl
		ld	(adstab), hl	; Adresa tabulky navesti
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

minsln:					; Vlozenie noveho riadku do zdrojoveho textu
		call	getend
		ex	de, hl
		dec	hl
		ld	a, (pdline)	; Buffer pre spakovany riadok zdrojoveho textu
		call	negbc		; Vrati	zapornu	dlzku spakovaneho riadku v zdrojovom texte
		ret	z

mi1:
		inc	hl
		push	hl
		ld	a, (hl)
		add	hl, bc
		ld	(hl), a
		pop	hl
		call	cmhlde		; Porovnanie HL	a DE
		jr	nz, mi1
		ld	hl, (lastln)	; Adresa posledneho riadku v zdrojovom texte
		add	hl, bc
		ld	(lastln), hl	; Adresa posledneho riadku v zdrojovom texte
		dec	hl
		ld	(adstab), hl	; Adresa tabulky navesti
		ld	hl, (curent)	; Adresa aktualneho riadku v zdrojovom texte

cpl2:					; Buffer pre spakovany riadok zdrojoveho textu
		ld	de, pdline
		push	de
		ld	a, (de)
		and	7Fh ; ''
		ld	c, a

mi2:
		ld	a, (de)
		ld	(hl), a
		dec	de
		dec	hl
		dec	c
		jr	nz, mi2
		pop	hl
		ld	(hl), c
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

getend:					; Zistenie kde v pameti	zacina zdrojovy	text
		ld	hl, (adstab)
		ld	c, (hl)
		call	vstoas		; Adresa labelu	 (In: C=cislo labelu  Out: DE=adresa labelu)
		ld	hl, (curent)	; Adresa aktualneho riadku v zdrojovom texte
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

delln:					; Editacia zdrojoveho textu - SS+CS - Zmazanie aktualneho riadku
		ld	bc, 0
		call	wlnnu0		; Vypis	cisla vpravo dole (0 = iba zmazanie)
		call	chblk		; Hladanie konca textu v textovom bufferi
		ld	hl, (curent)	; Adresa aktualneho riadku v zdrojovom texte
		jr	nz, dl10
		ld	a, (hl)
		or	a
		jp	z, edit0

dl10:
		push	hl
		ld	a, 16h
		call	idelln		; Posun	(casti)	obrazovky smerom hore
		ld	hl, insyes
		ld	d, (hl)
		ld	(hl), 0
		ld	a, (row)
		pop	hl
		cp	16h
		jr	z, dl3
		push	af
		push	hl
		add	a, d
		ld	e, a

dl1:					; Presun na dalsi riadok v zdrojovom texte
		call	skipln
		ld	a, e
		jr	z, dl2
		inc	e
		ld	a, 16h
		cp	e
		jr	nc, dl1

dl2:
		ld	(row), a
		call	outln		; Nacita, depakuje a vypise aktualny riadok zdrojoveho textu
		pop	hl
		ld	(curent), hl	; Adresa aktualneho riadku v zdrojovom texte
		pop	af
		ld	(row), a

dl3:
		dec	d
		call	m, mdelln	; Zmazanie aktualneho riadku v zdrojovom texte
		jp	edit1

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

outcrl:					; Presun kurzora na zaciatok noveho riadku
		ld	a, 0Dh

;   outchr - vypisuje znak na  poziciu	oznacenu  jazdcom  a  jazdca  posunie
;	     doprava.	na  konci  riadku  prejde  na  novy  riadok, na	konci
;	     obrazovky posunie obrazovku hore.	outchr spravne	osetri	tieto
;	     riadiace znaky:
;
;	       #19 - posun jazdca vlavo
;	       #18 - posun jazdca vpravo
;	       #0d - ukoncenie riadku a	prechod	na novy	riadok
;
;	     na	obrazovke sa jazdec nezobrazi, (zabezpecuje to modul  setcrs)
;	     modifikuje	sa len premenna	cursor.
;	     vstup:  <a> = kod znaku
;	     vystup:
;	     meni sa:  <af>

outchr:					; Vypis	jedneho	znaku na obrazovku
		cp	0Ah
		ret	z
		cp	0Ch
		ret	z
		push	hl
		ld	hl, (cursor)	; Aktualna pozicia vypisu. Prvy	bajt je	stlpec 0-31, druhy bajt	je riadok 0-23.
		cp	20h ; ' '
		jp	c, spec
		push	hl
		call	setchr		; Vykreslenie jedneho znaku na aktualnu	poziciu	podla kurzora
		pop	hl
		inc	l
		ld	a, 20h ; ' '
		sub	l
		jr	nz, newc

newl:
		ld	l, a
		ld	a, h
		sub	16h
		adc	a, 16h
		ld	h, a
		call	nc, scrol1	; Posun	obrazovky smerom hore

newc:					; Aktualna pozicia vypisu. Prvy	bajt je	stlpec 0-31, druhy bajt	je riadok 0-23.
		ld	(cursor), hl
		pop	hl
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

spec:
		sub	0Dh
		jr	z, newl
		ld	de, newc
		push	de
		sub	0Ch
		jr	z, lvlavo
		sub	0FFh
		ret	nz
		ld	a, 3Eh ; '>'
		cp	l
		ret	c
		inc	l
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

lvlavo:
		dec	l
		ret	p
		inc	l
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

delete:					; Editacia zdrojoveho textu - DELETE - zmazanie	znaku
		ld	a, (hl)
		cp	20h ; ' '
		jr	nz, de1
		ld	(hl), 0
		push	hl
		ld	l, 40h ; '@'

de0:
		dec	l
		cp	(hl)
		jr	z, de0
		inc	(hl)
		dec	(hl)
		pop	hl
		ld	(hl), a
		jr	nz, de1
		ld	a, (newcur)
		cp	l
		ret	z
		dec	l
		ld	(hl), 20h ; ' '
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

de1:
		call	field0
		ld	e, l

de2:
		cp	l
		ld	(hl), 20h ; ' '
		ex	de, hl
		ret	z
		ex	de, hl
		inc	l
		ld	d, (hl)
		dec	l
		ld	(hl), d
		inc	l
		jr	de2

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

insert:					; Editacia zdrojoveho textu - GRAPH - insert - vytvorenie miesta pre znak
		call	field0
		ld	d, a
		ld	a, l
		ld	l, d

in1:
		cp	l
		ld	(hl), 20h ; ' '
		ret	z
		dec	l
		ld	d, (hl)
		inc	l
		ld	(hl), d
		dec	l
		jr	in1

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

ascii:
		call	qcomst
		jr	c, spctab
		ld	(hl), b

right:					; Editacia zdrojoveho textu - CS+8 - posun vpravo
		ld	a, 3Eh ; '>'
		cp	l
		jr	c, beep		; Vyraznejsi zvukovy signal so zachovanim AF
		inc	l
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

spctab:
		inc	a

st1:
		cp	l
		ret	z
		ld	(hl), 20h ; ' '
		inc	l
		jr	st1

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

chcc:					; Textovy buffer pre jeden riadok na obrazovke
		ld	a, (buffer)
		cp	3Bh ; ';'
		ret	z
		cp	2Ah ; '*'
		ret	z
		ld	a, (row)
		cp	17h
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

tabr:					; Editacia zdrojoveho textu - CS+4 - presun na dalsie pole vpravo
		call	chcc
		jr	z, beep		; Vyraznejsi zvukovy signal so zachovanim AF
		call	field
		sub	3Fh ; '?'
		adc	a, 3Fh ; '?'
		cp	l
		jr	z, beep		; Vyraznejsi zvukovy signal so zachovanim AF
		ld	l, a
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

tabl:					; Editacia zdrojoveho textu - CS+1 - presun na predchadzajuce pole vlavo
		call	chcc
		jr	z, beep		; Vyraznejsi zvukovy signal so zachovanim AF
		call	field
		ld	a, l
		or	a
		jr	z, beep		; Vyraznejsi zvukovy signal so zachovanim AF

tl1:
		dec	de
		ld	a, (de)
		cp	l
		ld	l, a
		jr	z, tl1
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

endadr:					; Editacia zdrojoveho textu - SS+SPACE - skok na posledny znak v poli adresy
		call	chcc
		jr	z, beep		; Vyraznejsi zvukovy signal so zachovanim AF
		ld	a, (buffer)	; Textovy buffer pre jeden riadok na obrazovke
		ld	b, 20h ; ' '
		ld	l, 20h ; ' '
		jp	endad1		; Hladanie konca textu od danej	pozicie

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

left:					; Editacia zdrojoveho textu - CS+5 - posun vlavo
		ld	a, (newcur)
		cp	l
		jr	z, beep		; Vyraznejsi zvukovy signal so zachovanim AF
		dec	l
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

beep:					; Vyraznejsi zvukovy signal so zachovanim AF
		push	af
		scf
		call	bbeep		; Zvukovy signal (CY=0:kratsi pip, CY=1:dlhsi pip)
		pop	af
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

bbeep:					; Zvukovy signal (CY=0:kratsi pip, CY=1:dlhsi pip)
		push	hl
		push	de
		push	bc
		push	iy
		ld	iy, 5C3Ah
		ld	hl, 64h	; 'd'
		ld	de, 4Bh	; 'K'
		jr	c, bbp
		ld	hl, 50h	; 'P'
		ld	de, 14h

bbp:					; Rutinka BEEP
		call	sysbep
		di
		pop	iy
		pop	bc
		pop	de
		pop	hl
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

field0:
		call	chcc
		ld	a, 3Fh ; '?'
		ret	z

field:
		ld	de, startf_1

fd1:
		ld	a, (de)
		dec	a
		cp	l
		ret	nc
		inc	de
		jr	fd1

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

qcomst:
		sub	20h ; ' '
		ret	nz
		ld	a, (row)
		cp	17h
		ret	z

qcoms0:
		xor	a
		sub	l
		ccf
		ld	a, 6
		ret	c
		call	field0
		ret	z
		cp	3Fh ; '?'
		ret	z
		cp	1Fh
		ret	c
		ld	de, buffer_params

qc1:
		ccf
		push	af

qc2:
		ld	a, l
		cp	e
		jr	nz, qc3
		pop	af
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

qc3:
		ld	a, (de)
		inc	de
		cp	27h ; '''
		jr	nz, qc2
		pop	af
		jr	qc1

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

mrsb:					; Vypis	osemznakoveho chyboveho	hlasenia
		ld	bc, 801h

mrsd:					; Dialogovy riadok bez vyhodnocovania prikazov
		ld	de, 0

mrs_x:					; Dialogovy riadok a biely border
		ld	a, 0Fh
		out	(0FEh),	a
		xor	a

;   mrs	   - praca s dialogovym	riadkom.  modul	 vypise	 pozadovany  text  do
;	     dialogoveho  riadku,  nacita  vstupny text	a podla	poziadavky ho
;	     analyzuje na trojznakove prikazy.	 vyvolanim  tohto  modulu  ma
;	     uzivatel  k dispozicii vsetky funkcie, ktore su popisane v	opise
;	     prace s modulom mrs.  to znamena,	ze  na	editovanie  textu  je
;	     mozne   vyuzit   klavesy  caps shift/5,8,9,0  vstup  textu	 vzdy
;	     ukoncuje klavesa enter
;
;	     vstup:  <a> = cislo pozicie v dialogovom riadku, od ktorej	sa ma
;	     vypisat pozadovany	text (0-31)
;		     <hl> = adresa vypisovaneho	textu
;		     <b> = dlzka vypisovaneho textu.  ak  <b>  =  0  text  sa
;	     nevypisuje
;		     <c> = 0 nic sa necita.  inac sa cita text z klavesnice a
;	     uklada sa do bufra	od adresy #fe00.
;		     <de> = adresa tabulky trojznakovych prikazov.  ak <de> =
;	     0	, nacitany text	sa neanalyzuje.	 v tabulke nasleduju za	sebou
;	     vzdy trojznakova skratka prikazu a	adresa	obsluzneho  programu.
;	     tabulka  je zakoncena binarnou 0.	ak je pozadovana tato analyza
;	     modul nevrati riadenie,  kym  uzivatel  nenapise  riadok,	ktory
;	     zacina pripustnym prikazom.
;
;	     vystup: <b> = pocet  nacitanych  znakov  bez  enter.    nacitany
;	     retazec je	ukonceny binarnou 0.
;		     <de> = adresa   nacitaneho	  retazca.     pokial	 bola
;	     pozadovana	 analyza trojznakovych prikazov, ukazuje <de> na prvy
;	     znak za prikazom.
;		     <hl> = ak	 bola	pozadovana   analyza	trojznakovych
;	     prikazov, obsahuje	adresu prislusneho podprogramu.
;	     meni sa:  <af>, <bc>, <de>, <hl>

mrs:					; Praca	s dialogovym riadkom
		push	hl
		call	blank		; Zmazanie textoveho buffera
		pop	hl

mrsin:					; Praca	s nezmazanym dialogovym	riadkom
		push	de
		ld	e, a
		ld	d, 0FEh	; ''

mrs1:
		ld	a, (hl)
		ld	(de), a
		inc	hl
		inc	de
		djnz	mrs1
		ld	l, b
		ld	h, 17h
		call	outbuf		; Vypis	textoveho buffera na dany riadok obrazovky
		ld	a, e
		pop	de
		dec	c
		ret	m
		ld	(atabr), de	; Adresa tabulky prikazov dekodovanych pri praci s dialogovym riadkom
		ld	(newcur), a
		ld	(leftm1), a	; Pozicia prveho editovatelneho	znaku za promptom
		pop	hl
		ld	(anavp), hl	; Navratova adresa pri zavolani	"mrs" aby sa "mrs2" vedel kam sa vratit

znovu:
		push	hl
		ld	hl, (cursor)	; Aktualna pozicia vypisu. Prvy	bajt je	stlpec 0-31, druhy bajt	je riadok 0-23.
		ld	(oldchr), hl	; Miesto pre odlozenie aktualnej polohy	kurzoru
		ld	hl, (newcur)
		ld	(cursor), hl	; Aktualna pozicia vypisu. Prvy	bajt je	stlpec 0-31, druhy bajt	je riadok 0-23.
		xor	a
		call	wrrow1
		call	chblk		; Hladanie konca textu v textovom bufferi
		inc	l
		ld	(hl), 0
		ld	(adzero), hl	; Poloha nuloveho bajtu	za zadanym textom
		ld	hl, (oldchr)	; Miesto pre odlozenie aktualnej polohy	kurzoru
		ld	(cursor), hl	; Aktualna pozicia vypisu. Prvy	bajt je	stlpec 0-31, druhy bajt	je riadok 0-23.
		ld	hl, (atabr)	; Adresa tabulky prikazov dekodovanych pri praci s dialogovym riadkom
		ld	a, h
		or	l
		ret	z
		ld	d, 0FEh	; ''

nextc:					; Pozicia prveho editovatelneho	znaku za promptom
		ld	a, (leftm1)
		ld	e, a
		ld	bc, 3

nc3:
		ld	a, (de)
		sub	(hl)
		jr	nz, nc1
		inc	hl
		inc	e
		dec	c
		jr	nz, nc3
		ld	c, (hl)
		inc	hl
		ld	h, (hl)
		ld	l, c
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

nc1:
		inc	c
		inc	c
		add	hl, bc
		xor	a
		sub	(hl)
		jp	m, nextc
		ld	hl, cmonit	; Prikazy modulu "mrs>"
		jr	nz, nextc

mrs3:
		pop	af

;   mrs2   - umozni opravit text nacitany modulom mrs.
;	     musi mu predchadzat volanie modulu	mrs s citanim retazca.
;	     vstup:  pouzije informacie	ziskane	pri praci modulu mrs.
;		     modul mrs2	sa !!!!!!  musi	volat instrukciou jp mrs2 !!!!!!
;	     vystup:  rovnaky ako pri module mrs
;	     meni sa:  <af>, <bc>, <de>, <hl>

mrs2:					; Oprava textu zadaneho	v module "mrs"
		call	beep
		ld	a, (leftm1)	; Pozicia prveho editovatelneho	znaku za promptom
		ld	(newcur), a
		ld	hl, (adzero)	; Poloha nuloveho bajtu	za zadanym textom
		ld	(hl), 20h ; ' '
		ld	hl, (anavp)	; Navratova adresa pri zavolani	"mrs" aby sa "mrs2" vedel kam sa vratit
		jr	znovu

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;   pntchr - vytlacenie	jedneho	znaku na tlaciaren.
;	     vstup:  <a> - kod tlaceneho znaku.
;	     vystup:
;	     meni sa:  <af>

pntchr:					; Vytlacenie jedneho znaku na tlaciaren
		jp	expnt

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

opschr:					; Vypis	jedneho	znaku pre vypis	listingu na obrazovke alebo tlaciarni
		push	bc
		push	hl

opsch3:					; Volanie rutinky pre vypis jedneho znaku listingu (outchr = obrazovka,	pntchr = tlaciaren)
		call	rom_0
		call	scan		; Nacitanie stavu klavesnice
		cp	11h

break:
		ld	hl, tbreak
		jp	z, wtmf_3
		cp	53h ; 'S'
		jr	nz, wt2

wt1:					; Nacitanie stavu klavesnice
		call	scan
		cp	51h ; 'Q'
		jr	nz, wt1

wt2:
		pop	hl
		pop	bc
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

analax:					; Vyhodnotenie riadku zacinajuceho hviezdickou
		push	de
		push	hl
		push	hl
		call	chblk		; Hladanie konca textu v textovom bufferi
		inc	hl
		ld	(hl), 0
		ex	(sp), hl
		inc	hl
		ld	a, (hl)
		inc	hl
		cp	70h ; 'p'
		jr	nz, ax0
		call	dcbn		; Prevod desiatkoveho cisla na 16bit hodnotu
		ld	a, d
		or	a
		jr	nz, ax6
		ld	d, 1
		ld	(newpag), de	; Pocet	riadkov	na jednu stranu	listingu zadany	pomocou	direktivy *p
		jr	ax5

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

ax0:
		cp	63h ; 'c'
		jr	nz, ax1
		call	hxbn		; Prevod hexadecimalneho cisla na 16bit	hodnotu
		ld	(pcode), de	; Adresa zadana	ORG-om alebo direktivou	*c kam sa bude ukladat kod
		jr	ax5

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

ax1:					; Vypis	jedneho	znaku na obrazovku
		ld	bc, outchr
		cp	74h ; 't'
		jr	z, ax2
		ld	bc, pntchr	; Vytlacenie jedneho znaku na tlaciaren
		cp	6Ch ; 'l'
		jr	nz, ax3
		ld	a, 87h ; ''

ax2:
		sub	67h ; 'g'
		ld	(scrlp+1), a	; Znak pre vypis listingu (0x0D	= obrazovka, 0x20 = tlaciaren)
		ld	(opsch3+1), bc	; Volanie rutinky pre vypis jedneho znaku listingu (outchr = obrazovka,	pntchr = tlaciaren)
		jr	ax5

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

ax3:
		sub	61h ; 'a'
		jr	z, ax4
		cp	4
		jr	nz, ax6
		ld	a, 2Ch ;     ; bbc - lind - 2 - 4

ax4:
		add	a, 4
		ld	(lind+1), a	; Skok pre vypis listingu: 0x04	= vsetko, 0x30 = iba chybne riadky

ax5:
		ld	a, (hl)
		or	a

ax6:
		pop	hl
		ld	(hl), 20h ; ' '
		pop	hl
		pop	de
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

wmg:					; Chvilka cakania
		djnz	$
		dec	hl
		ld	a, h
		or	l
		jr	nz, wmg		; Chvilka cakania
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

savtxt:					; Prikaz edi>sav - ulozenie zdrojoveho textu
		call	getend
		ld	hl, lastln	; Adresa posledneho riadku v zdrojovom texte
		ld	bc, edi		; Prikaz mrs>edi - skok	do modulu edi>
		ld	a, 0FFh

save:
		push	bc
		ld	(ind_1+1), a
		ld	bc, buffer_instr
		push	bc
		ld	a, (bc)
		cp	20h ; ' '
		jp	nz, mrs2	; Oprava textu zadaneho	v module "mrs"
		sbc	hl, de
		ex	de, hl
		ex	(sp), hl
		ld	(hl), 3
		xor	a

sa1_edi:
		inc	hl
		cp	(hl)
		jr	nz, sa1_edi
		ld	(hl), 20h ; ' '
		ld	hl, 50E0h
		call	blvst
		ld	hl, buffer_dlzka
		ld	(hl), e
		inc	hl
		ld	(hl), d
		pop	de
		inc	hl
		ld	(hl), e
		inc	hl
		ld	(hl), d

ind_1:
		ld	a, 0
		inc	hl
		ld	(hl), a
		inc	hl
		ld	(hl), a
		xor	a
		ld	de, 11h
		ld	ix, buffer_instr
		call	save_4C6	; Ukladanie na pasku
		jr	nc, exsav
		ld	hl, 500h
		call	wmg		; Chvilka cakania
		ld	de, (buffer_dlzka)
		ld	ix, (buffer_adresa)
		ld	a, 0FFh
		call	save_4C6	; Ukladanie na pasku

exsav:
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

loatxt:					; Prikaz edi>loa - nahratie zdrojoveho textu
		ld	hl, slln0
		ld	a, 21h ; '!'
		jr	lmtxt

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

mertxt:					; Prikaz edi>mer - prihratie noveho zdrojoveho textu do	stareho
		ld	hl, text
		ld	a, 1

lmtxt:
		ld	(ld10+1), hl
		ld	(loamer), a
		ld	a, 1
		ld	hl, edi		; Prikaz mrs>edi - skok	do modulu edi>

load:
		ld	(ldind), a
		ld	a, (de)
		inc	de
		cp	20h ; ' '
		jr	z, lo1
		or	a
		jp	nz, mrs2	; Oprava textu zadaneho	v module "mrs"
		dec	a
		ld	(de), a

lo1:
		push	hl
		ld	hl, 50E0h
		call	blvst

lo2:					; Rychly test klavesy BREAK
		call	brktst
		ret	nc
		xor	a
		ld	de, 11h
		ld	ix, buffer_comment
		scf
		call	mgld
		jr	nc, lo2
		ld	h, 17h
		ld	l, 0
		ld	(cursor), hl	; Aktualna pozicia vypisu. Prvy	bajt je	stlpec 0-31, druhy bajt	je riadok 0-23.
		ld	hl, buffer_comment
		ld	a, (hl)
		cp	3
		jr	nz, lo2
		inc	hl
		ld	b, 0Ah
		ld	c, b
		ld	de, buffer_meno

lo3:
		ld	a, (hl)
		call	outchr		; Vypis	jedneho	znaku na obrazovku
		ld	a, (de)
		inc	a
		jr	z, lo52
		dec	a
		jr	nz, lo51
		dec	de
		ld	a, 20h ; ' '

lo51:
		cp	(hl)
		jr	z, lo5
		ld	c, 1

lo5:
		inc	de

lo52:
		inc	hl
		djnz	lo3
		dec	c
		jr	z, lo2
		ld	e, (hl)
		inc	hl
		ld	d, (hl)
		inc	hl
		ld	c, (hl)
		inc	hl
		ld	b, (hl)
		inc	hl
		ld	a, (hl)
		inc	hl
		cp	(hl)
		jr	nz, lo2
		or	(hl)
		jr	z, lo53
		inc	a
		jr	nz, lo2
		inc	a

lo53:
		ld	hl, ldind
		cp	(hl)
		jr	nz, lo2
		ld	hl, ld10
		ld	(hl), 0CDh ; ''
		or	a
		jr	nz, lo6
		ld	(hl), 0C9h ; ''
		ld	h, b
		ld	l, c
		push	de
		push	hl
		add	hl, de
		ex	de, hl
		ld	hl, (lastln)	; Adresa posledneho riadku v zdrojovom texte
		ld	a, e
		sub	l
		ld	a, d
		sbc	a, h
		pop	hl
		jr	lo7

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

lo6:					; Adresa posledneho riadku v zdrojovom texte
		ld	hl, (lastln)
		ld	bc, -852h
		add	hl, bc

loamer:					; Adresa posledneho riadku v zdrojovom texte
		ld	bc,  lastln+1
		sbc	hl, de
		jr	c, wtmf		; Chybove hlasenie "MEM FULL"
		push	de
		ex	de, hl
		ld	hl, (libtop)	; Koniec kniznice a zaciatok volnej pamete
		ld	(memory), hl	; Koniec kniznice a zaciatok volnej pamete
		ld	a, l
		sub	e
		ld	a, h
		sbc	a, d
		ex	de, hl

lo7:
		pop	de
		jr	c, lo9

wtmf:					; Chybove hlasenie "MEM FULL"
		ld	hl, tmf

wtmf_3:					; Hodnota SP pri spusteni systemu MRS
		ld	sp, (stack)
		call	mrsb		; Vypis	osemznakoveho chyboveho	hlasenia
		jp	monit		; Vstup	do modulu "mrs>"

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

lo9:
		call	text

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

		db ' loading',0

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

		push	hl
		pop	ix
		add	hl, de
		push	hl
		scf
		dec	a
		call	mgld
		pop	hl
		jr	c, ld10
		call	brktst		; Rychly test klavesy BREAK
		ret	nc
		ld	hl, tioer
		jp	mrsb		; Vypis	osemznakoveho chyboveho	hlasenia

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

ld10:
		call	text

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

		db ' wait',0

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

		dec	hl
		ld	e, l
		ld	d, h

lo11:					; Vrati	zapornu	dlzku spakovaneho riadku v zdrojovom texte
		call	negbc0
		add	hl, bc
		jr	nz, lo11
		dec	hl
		ex	de, hl

loains:					; Vkladanie novych riadkov do zdrojoveho textu
		ld	(calins+1), bc

ld2:
		push	de
		ld	a, 1
		ld	(insyes), a
		ld	a, (ldind)
		dec	a
		jr	z, ld3
		push	hl
		call	blank		; Zmazanie textoveho buffera
		call	tstend		; Overenie ci je medzi koncom kniznice a zaciatkom zdrojoveho textu aspon 64 bajtov miesta
		pop	hl
		pop	de
		jr	nc, wtmf	; Chybove hlasenie "MEM FULL"

calins:					; Volanie daneho podprogramu pre ziskanie jedneho riadku zdrojoveho textu
		call	rom_0
		jp	c, edi		; Prikaz mrs>edi - skok	do modulu edi>
		push	de
		jr	ld4

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

ld3:
		ex	(sp), hl
		ld	de, (adstab)	; Adresa tabulky navesti
		ld	(adstab), hl	; Adresa tabulky navesti
		ex	(sp), hl
		push	de
		call	unpln		; Nacita a depakuje riadok zdrojoveho textu do textoveho buffera
		pop	de
		ld	(adstab), de	; Adresa tabulky navesti

ld4:
		push	hl

ld5:
		xor	a
		ld	(rnznop), a
		call	pln
		ld	a, 0C0h	; ''
		ld	(rnznop), a
		jr	z, ld6
		ld	h, 3
		call	wmg		; Chvilka cakania
		call	brktst		; Rychly test klavesy BREAK
		jp	nc, break
		call	wlnnum		; Vypis	cisla editovaneho riadku vpravo	dole
		xor	a
		ld	(row), a
		call	wrrow1
		jr	ld5

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

ld6:					; Adresa aktualneho riadku v zdrojovom texte
		ld	hl, (curent)
		call	skln		; Preskoc riadok zdrojoveho textu na ktory ukazuje HL a	nastav sa na dalsi riadok
		pop	hl
		pop	de
		ld	a, (ldind)
		dec	a
		jr	nz, ld2
		cp	(hl)
		ret	z
		jr	ld2

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

instxt:					; Prikaz edi>ins - moznost pluginu pre vytvaranie zdrojoveho textu
		ld	bc, hxbn
		call	getli0		; Nacitanie intervalu dvoch cislic (BC = hxbn alebo dcbn)
		jp	nz, mrs2	; Oprava textu zadaneho	v module "mrs"
		ld	b, h
		ld	c, l
		ex	de, hl
		jr	loains		; Vkladanie novych riadkov do zdrojoveho textu

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

dis1h:
		ld	a, e
		sub	l
		ld	a, d
		sbc	a, h
		ret	c
		push	de
		call	disrow		; Disasemblovanie jednej instrukcie na adrese HL
		pop	de
		or	a
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

mgld:
		inc	d
		ex	af, af'
		dec	d
		di
		ld	a, 0Fh
		out	(0FEh),	a
		jp	load_562	; Nacitanie z pasky

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

text:
		ex	(sp), hl

txt:
		ld	a, (hl)
		inc	hl
		or	a
		jr	z, endtx
		call	outchr		; Vypis	jedneho	znaku na obrazovku
		jr	txt

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

endtx:
		ex	(sp), hl
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

getlim:					; Nacitanie intervalu dvoch desiatkovych cislic	 DDDDD-DDDDD
		ld	bc, dcbn

getli0:					; Nacitanie intervalu dvoch cislic (BC = hxbn alebo dcbn)
		ld	a, (de)
		cp	20h ; ' '
		ret	nz
		inc	de
		ex	de, hl
		call	dh		; call (bc)
		ld	a, (hl)
		cp	2Dh ; '-'
		ret	nz
		push	de
		inc	hl
		call	dh		; call (bc)
		ld	a, (hl)
		pop	hl
		or	a
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

dis:					; Prikaz edi>dis - spetny prekladac strojoveho kodu do zdrojoveho textu
		ld	bc, hxbn
		call	getli0		; Nacitanie intervalu dvoch cislic (BC = hxbn alebo dcbn)
		jp	nz, mrs2	; Oprava textu zadaneho	v module "mrs"
		ld	bc, dis1h
		jp	loains		; Vkladanie novych riadkov do zdrojoveho textu

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

dh:					; call (bc)
		push	bc
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

wlnnum:					; Vypis	cisla editovaneho riadku vpravo	dole
		ld	bc, (lnnumb)
		inc	bc

wlnnu0:					; Vypis	cisla vpravo dole (0 = iba zmazanie)
		push	hl
		ld	hl, edi_riadok
		push	hl
		ld	a, b
		or	c
		call	nz, bndc	; Prevod 16bit hodnoty na desiatkove cislo
		pop	de
		ld	hl, 50FCh

wln1:
		ld	a, (de)
		call	pixel		; Vykreslenie jedneho znaku na obrazovku (A = ascii kod, DE = pozicia vo videoram)
		inc	l
		inc	e
		jr	nz, wln1
		call	bbc		; Zmazanie casti buffera pre cislo editovaneho riadku
		pop	hl
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

delblk:					; Prikaz edi>dlb - Zmazanie casti zdrojoveho textu
		call	getlim
		jp	nz, mrs2	; Oprava textu zadaneho	v module "mrs"
		cp	a
		ex	de, hl
		sbc	hl, de
		jp	c, mrs2		; Oprava textu zadaneho	v module "mrs"
		push	hl
		dec	de
		call	sline		; Najdi	DE-ty riadok v zdrojovom texte

dlb1:					; Zmazanie aktualneho riadku v zdrojovom texte
		call	mdelln
		pop	hl
		ld	a, h
		or	l
		dec	hl
		push	hl
		jr	nz, dlb1
		pop	hl
		jp	edi		; Prikaz mrs>edi - skok	do modulu edi>

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

cpyblk:					; Prikaz edi>dlb - Skopirovanie	casti zdrojoveho textu
		call	getlim
		dec	de
		dec	hl
		ld	a, 13h
		ld	(inc2),	a
		ld	bc, (lnnumb)	; Cislo	aktualneho riadku v zdrojovom texte
		ld	a, c
		sub	l
		ld	a, b
		sbc	a, h
		jr	c, cpb1
		xor	a
		ld	(inc2),	a
		ld	a, e
		sub	c
		ld	a, d
		sbc	a, b
		jp	nc, mrs2	; Oprava textu zadaneho	v module "mrs"

cpb1:
		ccf
		ex	de, hl
		sbc	hl, de

cpb2:
		push	hl
		push	de
		push	bc
		call	sline		; Najdi	DE-ty riadok v zdrojovom texte
		ld	de, pdline	; Buffer pre spakovany riadok zdrojoveho textu
		ld	a, (hl)
		and	7Fh ; ''
		ld	c, a
		jr	z, cpb3
		ld	b, 0
		lddr
		call	tstend		; Overenie ci je medzi koncom kniznice a zaciatkom zdrojoveho textu aspon 64 bajtov miesta
		jp	nc, wtmf	; Chybove hlasenie "MEM FULL"
		pop	de
		push	de
		call	sline		; Najdi	DE-ty riadok v zdrojovom texte
		call	minsln		; Vlozenie noveho riadku do zdrojoveho textu

cpb3:
		pop	bc
		pop	de
		pop	hl
		inc	bc
		inc	de

inc2:
		nop
		ld	a, h
		or	l
		dec	hl
		jr	nz, cpb2
		jp	edi		; Prikaz mrs>edi - skok	do modulu edi>

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

code:		db 0			; Operacny kod instrukcie
flags:		db 0
nxtadr:		dw 0			; Adresa dalsej	instrukcie
erradr:		dw 0
errind:		db 0
gstabh:		dw reg1
		dw pair
		dw _byte
		dw word
		dw cond
		dw num
		dw rest
		dw regx
		dw areg
		dw dfreg
		dw hlreg
		dw spreg
		dw agreg
		dw shcnd
		dw creg
lastlb:		db 0

oprts:		db  2Bh	; +		; Operatory pre	vyrazy v zdrojovom texte
		db  2Dh	; -
		db  2Ah	; *
		db  2Fh	; /
		db  26h	; &
		db  21h	; !
oprts_6:	db  40h	; @

regbse:		db  62h	; b		; 8-bitove registre
		db  63h	; c
		db  64h	; d
		db  65h	; e
		db  68h	; h
		db  6Ch	; l
		db    0
regbse_7:	db  61h	; a		; 8-bitove registre

parbse:		db 'bc'              ; 16-bitove registre
		db 'de'
		db 'hl'
		db 'sp'
		db 'af'
		db 'ix'
		db 'iy'

cdrsf:		db 'nz'              ; Podmienky v podmienenych skokoch
		db 'z',  0
		db 'nc'
		db 'c',  0
		db 'po'
		db 'pe'
		db 'p',  0
		db 'm',  0

mstab:		db 0FFh
		db 0C7h	; 
		db 0CFh	; 
		db 0FFh
		db 0FFh
		db 0C7h	; 
		db 0C7h	; 
		db 0C7h	; 
		db 0F7h	; 
		db 0FFh
		db 0FFh
		db 0FFh
		db 0FFh
		db 0FFh
		db 0E7h	; 
		db 0FFh

insbse:		db  68h	; h
		db  6Ch	; l
		db 0F4h	; 
		db  80h	; 
		db    0
		db  76h	; v
		db  6Ch	; l
		db 0E4h	; 
		db    1
		db    1
		db  40h	; @
		db  29h	; )
		db    8
		db  57h	; W
		db  28h	; (
		db    9
		db  47h	; G
		db  0Ch
		db  0Bh
		db 0F9h	; 
		db  0Bh
		db  14h
		db  2Ah	; *
		db  14h
		db  0Bh
		db  22h	; "
		db    9
		db  12h
		db  0Ah
		db    9
		db  14h
		db  3Ah	; :
		db    1
		db    3
		db    6
		db  12h
		db    9
		db    2
		db  22h	; "
		db  14h
		db  4Bh	; K
		db    2
		db    4
		db    1
		db  34h	; 4
		db    2
		db  43h	; C
		db  94h	; 
		db    9
		db  32h	; 2
		db  70h	; p
		db  75h	; u
		db  73h	; s
		db 0E8h	; 
		db  82h	; 
		db    0
		db 0C5h	; 
		db  70h	; p
		db  6Fh	; o
		db 0F0h	; 
		db  82h	; 
		db    0
		db 0C1h	; 
		db  6Ah	; j
		db 0F2h	; 
		db  0Eh
		db    3
		db  20h
		db  80h	; 
		db    3
		db  18h
		db  64h	; d
		db  6Ah	; j
		db  6Eh	; n
		db 0FAh	; 
		db  80h	; 
		db    3
		db  10h
		db  6Ah	; j
		db 0F0h	; 
		db    5
		db    4
		db 0C2h	; 
		db  1Bh
		db    0
		db 0E9h	; 
		db  80h	; 
		db    4
		db 0C3h	; 
		db  63h	; c
		db  61h	; a
		db  6Ch	; l
		db 0ECh	; 
		db    5
		db    4
		db 0C4h	; 
		db  80h	; 
		db    4
		db 0CDh	; 
		db  72h	; r
		db  65h	; e
		db 0F4h	; 
		db    5
		db    0
		db 0C0h	; 
		db  80h	; 
		db    0
		db 0C9h	; 
		db  69h	; i
		db 0EEh	; 
		db  21h	; !
		db  1Fh
		db  40h	; @
		db  89h	; 
		db  13h
		db 0DBh	; 
		db  6Fh	; o
		db  75h	; u
		db 0F4h	; 
		db  3Fh	; ?
		db  81h	; 
		db  41h	; A
		db  93h	; 
		db    9
		db 0D3h	; 
		db  61h	; a
		db  64h	; d
		db 0E4h	; 
		db    9
		db    1
		db  80h	; 
		db    9
		db    3
		db 0C6h	; 
		db  8Bh	; 
		db    2
		db    9
		db  61h	; a
		db  64h	; d
		db 0E3h	; 
		db    9
		db    1
		db  88h	; 
		db    9
		db    3
		db 0CEh	; 
		db 0ABh	; 
		db    2
		db  4Ah	; J
		db  73h	; s
		db  75h	; u
		db 0E2h	; 
		db    0
		db    1
		db  90h	; 
		db  80h	; 
		db    3
		db 0D6h	; 
		db  73h	; s
		db  62h	; b
		db 0E3h	; 
		db    9
		db    1
		db  98h	; 
		db    9
		db    3
		db 0DEh	; 
		db 0ABh	; 
		db    2
		db  42h	; B
		db  61h	; a
		db  6Eh	; n
		db 0E4h	; 
		db    0
		db    1
		db 0A0h	; 
		db  80h	; 
		db    3
		db 0E6h	; 
		db  78h	; x
		db  6Fh	; o
		db 0F2h	; 
		db    0
		db    1
		db 0A8h	; 
		db  80h	; 
		db    3
		db 0EEh	; 
		db  6Fh	; o
		db 0F2h	; 
		db    0
		db    1
		db 0B0h	; 
		db  80h	; 
		db    3
		db 0F6h	; 
		db  63h	; c
		db 0F0h	; 
		db    0
		db    1
		db 0B8h	; 
		db  80h	; 
		db    3
		db 0FEh	; 
		db  69h	; i
		db  6Eh	; n
		db 0E3h	; 
		db    1
		db    0
		db    4
		db  82h	; 
		db    0
		db    3
		db  64h	; d
		db  65h	; e
		db 0E3h	; 
		db    1
		db    0
		db    5
		db  82h	; 
		db    0
		db  0Bh
		db  65h	; e
		db 0F8h	; 
		db  1Ch
		db  0Bh
		db 0E3h	; 
		db  0Dh
		db  0Dh
		db    8
		db  8Ah	; 
		db  0Bh
		db 0EBh	; 
		db  65h	; e
		db  78h	; x
		db 0F8h	; 
		db  80h	; 
		db    0
		db 0D9h	; 
		db  6Eh	; n
		db  6Fh	; o
		db 0F0h	; 
		db  80h	; 
		db    0
		db    0
		db  72h	; r
		db  6Ch	; l
		db  63h	; c
		db 0E1h	; 
		db  80h	; 
		db    0
		db    7
		db  72h	; r
		db  72h	; r
		db  63h	; c
		db 0E1h	; 
		db  80h	; 
		db    0
		db  0Fh
		db  72h	; r
		db  6Ch	; l
		db 0E1h	; 
		db  80h	; 
		db    0
		db  17h
		db  72h	; r
		db  72h	; r
		db 0E1h	; 
		db  80h	; 
		db    0
		db  1Fh
		db  64h	; d
		db  61h	; a
		db 0E1h	; 
		db  80h	; 
		db    0
		db  27h	; '
		db  63h	; c
		db  70h	; p
		db 0ECh	; 
		db  80h	; 
		db    0
		db  2Fh	; /
		db  73h	; s
		db  63h	; c
		db 0E6h	; 
		db  80h	; 
		db    0
		db  37h	; 7
		db  63h	; c
		db  63h	; c
		db 0E6h	; 
		db  80h	; 
		db    0
		db  3Fh	; ?
		db  65h	; e
		db 0E9h	; 
		db  80h	; 
		db    0
		db 0FBh	; 
		db  64h	; d
		db 0E9h	; 
		db  80h	; 
		db    0
		db 0F3h	; 
		db  62h	; b
		db  69h	; i
		db 0F4h	; 
		db 0C6h	; 
		db    1
		db  40h	; @
		db  73h	; s
		db  65h	; e
		db 0F4h	; 
		db 0C6h	; 
		db    1
		db 0C0h	; 
		db  72h	; r
		db  65h	; e
		db 0F3h	; 
		db 0C6h	; 
		db    1
		db  80h	; 
		db  72h	; r
		db  6Ch	; l
		db 0E3h	; 
		db 0C0h	; 
		db    1
		db    0
		db  72h	; r
		db 0ECh	; 
		db 0C0h	; 
		db    1
		db  10h
		db  72h	; r
		db  72h	; r
		db 0E3h	; 
		db 0C0h	; 
		db    1
		db    8
		db  72h	; r
		db 0F2h	; 
		db 0C0h	; 
		db    1
		db  18h
		db  73h	; s
		db  6Ch	; l
		db 0E1h	; 
		db 0C0h	; 
		db    1
		db  20h
		db  73h	; s
		db  72h	; r
		db 0E1h	; 
		db 0C0h	; 
		db    1
		db  28h	; (
		db  73h	; s
		db  6Ch	; l
		db 0ECh	; 
		db 0C0h	; 
		db    1
		db  30h	; 0
		db  73h	; s
		db  72h	; r
		db 0ECh	; 
		db 0C0h	; 
		db    1
		db  38h	; 8
		db  6Ch	; l
		db  64h	; d
		db 0E9h	; 
		db 0A0h	; 
		db    0
		db 0A0h	; 
		db  6Ch	; l
		db  64h	; d
		db  69h	; i
		db 0F2h	; 
		db 0A0h	; 
		db    0
		db 0B0h	; 
		db  6Ch	; l
		db  64h	; d
		db 0E4h	; 
		db 0A0h	; 
		db    0
		db 0A8h	; 
		db  6Ch	; l
		db  64h	; d
		db  64h	; d
		db 0F2h	; 
		db 0A0h	; 
		db    0
		db 0B8h	; 
		db  63h	; c
		db  70h	; p
		db 0E9h	; 
		db 0A0h	; 
		db    0
		db 0A1h	; 
		db  63h	; c
		db  70h	; p
		db  69h	; i
		db 0F2h	; 
		db 0A0h	; 
		db    0
		db 0B1h	; 
		db  63h	; c
		db  70h	; p
		db 0E4h	; 
		db 0A0h	; 
		db    0
		db 0A9h	; 
		db  63h	; c
		db  70h	; p
		db  64h	; d
		db 0F2h	; 
		db 0A0h	; 
		db    0
		db 0B9h	; 
		db  69h	; i
		db  6Eh	; n
		db 0E9h	; 
		db 0A0h	; 
		db    0
		db 0A2h	; 
		db  69h	; i
		db  6Eh	; n
		db 0E4h	; 
		db 0A0h	; 
		db    0
		db 0AAh	; 
		db  69h	; i
		db  6Eh	; n
		db  69h	; i
		db 0F2h	; 
		db 0A0h	; 
		db    0
		db 0B2h	; 
		db  69h	; i
		db  6Eh	; n
		db  64h	; d
		db 0F2h	; 
		db 0A0h	; 
		db    0
		db 0BAh	; 
		db  6Fh	; o
		db  75h	; u
		db  74h	; t
		db 0E9h	; 
		db 0A0h	; 
		db    0
		db 0A3h	; 
		db  6Fh	; o
		db  75h	; u
		db  74h	; t
		db 0E4h	; 
		db 0A0h	; 
		db    0
		db 0ABh	; 
		db  6Fh	; o
		db  74h	; t
		db  69h	; i
		db 0F2h	; 
		db 0A0h	; 
		db    0
		db 0B3h	; 
		db  6Fh	; o
		db  74h	; t
		db  64h	; d
		db 0F2h	; 
		db 0A0h	; 
		db    0
		db 0BBh	; 
		db  72h	; r
		db  6Ch	; l
		db 0E4h	; 
		db 0A0h	; 
		db    0
		db  6Fh	; o
		db  72h	; r
		db  72h	; r
		db 0E4h	; 
		db 0A0h	; 
		db    0
		db  67h	; g
		db  6Eh	; n
		db  65h	; e
		db 0E7h	; 
		db 0A0h	; 
		db    0
		db  44h	; D
		db  69h	; i
		db  6Dh	; m
		db 0B0h	; 
		db 0A0h	; 
		db    0
		db  46h	; F
		db  69h	; i
		db  6Dh	; m
		db 0B1h	; 
		db 0A0h	; 
		db    0
		db  56h	; V
		db  69h	; i
		db  6Dh	; m
		db 0B2h	; 
		db 0A0h	; 
		db    0
		db  5Eh	; ^
		db  72h	; r
		db  65h	; e
		db  74h	; t
		db 0E9h	; 
		db 0A0h	; 
		db    0
		db  4Dh	; M
		db  72h	; r
		db  65h	; e
		db  74h	; t
		db 0EEh	; 
		db 0A0h	; 
		db    0
		db  45h	; E
		db  72h	; r
		db  73h	; s
		db 0F4h	; 
		db  87h	; 
		db    0
		db 0C7h	; 
		db    0
psibse:		db  65h	; e
		db  6Eh	; n
		db 0F4h	; 
		db    0
		db  65h	; e
		db  78h	; x
		db 0F4h	; 
		db    2
		db  64h	; d
		db 0E2h	; 
		db    4
		db  64h	; d
		db 0F7h	; 
		db    6
		db  6Fh	; o
		db  72h	; r
		db 0E7h	; 
		db    8
		db  64h	; d
		db 0F3h	; 
		db  0Ah
		db  65h	; e
		db  71h	; q
		db 0F5h	; 
		db  0Ch
		db  65h	; e
		db  6Eh	; n
		db 0E4h	; 
		db  0Eh
		db    0

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

packln:					; Spakovanie textoveho riadku do formatu zdrojoveho textu
		ld	hl, pdline
		xor	a
		ld	(hl), a
		ld	(errind), a
		push	hl
		ex	de, hl
		ld	hl, buffer	; Textovy buffer pre jeden riadok na obrazovke
		ld	a, (hl)
		cp	20h ; ' '
		jr	z, fnl
		sub	3Bh ; ';'
		jr	z, onlycm
		cp	0EFh ; ''      ; cp '*'
		jr	nz, lab
		call	analax		; Vyhodnotenie riadku zacinajuceho hviezdickou
		jr	nz, emsg

onlycm:
		dec	de
		ld	c, 41h ; 'A'

onlylb:
		dec	a
		ld	(de), a
		dec	de
		ex	de, hl
		ld	(nxtadr), hl	; Adresa dalsej	instrukcie
		jp	comfld

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

lab:
		push	de
		call	fndlbl		; Vyhladanie navestia v	tabulke	navesti
		pop	de
		jr	nz, emsg
		ld	a, 80h ; ''
		ld	(de), a
		dec	de
		ld	a, c
		cp	1
		jr	c, emsg
		ld	(de), a

fnl:
		ld	a, 7
		ld	(errind), a
		ld	l, a
		dec	de
		ld	a, (hl)
		ld	c, 21h ; '!'
		sub	21h ; '!'
		jr	c, onlylb
		push	de
		call	instr_asm	; Najdenie instrukcie Z80 podla	jej nazvu
		pop	de
		call	nz, pseudo	; Najdenie pseudoinstrukcie podla jej nazvu
		jr	nz, emsg

fn:
		push	de
		dec	de
		dec	de
		ld	(nxtadr), de	; Adresa dalsej	instrukcie
		ld	a, (bc)
		ld	d, a
		rra
		and	30h ; '0'
		ld	(flags), a
		inc	bc
		ld	a, (bc)
		ld	e, a
		inc	bc
		ld	a, (bc)
		ld	(code),	a	; Operacny kod instrukcie
		inc	bc
		ld	a, d
		or	e
		and	1Fh
		jr	z, f6
		push	hl
		push	bc
		ld	a, 0Ch
		ld	(errind), a
		ld	l, a
		ld	a, d
		push	de
		and	1Fh
		jr	z, f4
		call	getop1
		jr	z, f2

fx:
		pop	af
		pop	bc
		pop	hl
		pop	de
		rla
		jr	nc, fn

emsg:
		pop	de
		ld	a, (errind)
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

f2:
		pop	de
		push	de
		ld	a, e
		or	a
		jr	z, f5
		ld	a, (hl)
		cp	2Ch ; 
		jr	nz, fx
		inc	hl

f4:
		ld	a, e
		or	a
		jr	z, f5
		call	getop2
		jr	nz, fx

f5:
		ld	a, (hl)
		cp	20h ; ' '
		jr	nz, fx
		pop	af
		pop	bc
		pop	bc

f6:
		pop	bc
		ld	a, (flags)
		ld	(bc), a
		cp	20h ; ' '
		jr	c, f7
		and	10h
		jr	nz, emsg

f7:
		dec	bc
		ld	a, (code)	; Operacny kod instrukcie
		ld	(bc), a
		push	af

psq:
		pop	af
		ld	c, 21h ; '!'
		ld	e, 1Fh
		ld	d, 0FEh	; ''
		ld	a, e
		sub	l
		ld	a, d
		sbc	a, h
		inc	e
		jr	c, emsg

comfld:
		ld	a, 20h ; ' '
		ld	l, 3Fh ; '?'
		ld	h, 0FEh	; ''

cf1:
		dec	c
		jr	z, cf2
		cp	(hl)
		dec	hl
		jr	z, cf1

cf2:					; Adresa dalsej	instrukcie
		ld	hl, (nxtadr)
		jr	z, cf4

cf3:
		ld	a, (de)
		ld	(hl), a
		inc	de
		dec	hl
		dec	c
		jr	nz, cf3

cf4:
		pop	de
		ex	de, hl
		ld	a, l
		sub	e
		or	(hl)
		ld	(hl), a
		cp	a
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

fndlbl:					; Vyhladanie navestia v	tabulke	navesti
		ld	a, (hl)
		cp	24h ; '$'
		ld	c, 0
		inc	hl
		scf
		ret	z
		dec	hl
		cp	61h ; 'a'
		ret	c
		ld	a, 7Ah ; 'z'
		cp	(hl)
		ret	c
		ex	de, hl
		ld	hl, (adstab)	; Adresa tabulky navesti
		ld	c, (hl)
		inc	c
		ex	de, hl
		push	de

fl1:
		pop	af
		push	de
		ld	a, c
		ld	(lastlb), a

fl3:
		dec	c

jrz:
		jr	z, wrlbl
		call	vstoas		; Adresa labelu	 (In: C=cislo labelu  Out: DE=adresa labelu)
		ld	a, (de)
		or	a
		jr	z, fl1
		push	hl
		push	de
		ld	b, 6

fl4:
		ld	a, (de)
		and	7Fh ; ''
		cp	(hl)
		jr	nz, chneq
		inc	hl
		inc	de
		djnz	fl4

leq:
		pop	de
		pop	de
		inc	sp
		inc	sp
		cp	a
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

chneq:
		cp	20h ; ' '
		jr	nz, lneq
		call	aphnum		; Zistenie ci dany znak	je alfanumericky 0-9 a-z
		jr	nc, leq

lneq:
		pop	de
		pop	hl
		jr	fl3

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

wrlbl:
		ex	(sp), hl
		push	hl
		ld	a, (hl)
		or	a
		ld	hl, (adstab)	; Adresa tabulky navesti
		jr	nz, wrl1
		or	(hl)
		jr	nz, wrl2

wrl1:
		inc	(hl)
		ld	c, (hl)
		jr	z, stf
		call	vstoas		; Adresa labelu	 (In: C=cislo labelu  Out: DE=adresa labelu)
		ex	(sp), hl
		ld	hl, (libtop)	; Koniec kniznice a zaciatok volnej pamete
		ld	a, l
		sub	e
		ld	a, h
		sbc	a, d
		pop	hl
		jr	c, wrl5

stf:
		dec	(hl)
		jp	wtmf		; Chybove hlasenie "MEM FULL"

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

wrl2:
		pop	de
		ld	a, (lastlb)
		ld	c, a

wrl5:
		pop	hl
		ld	b, 6

wrl3:					; Zistenie ci dany znak	je alfanumericky 0-9 a-z
		call	aphnum
		jr	c, wrl4
		ld	a, 20h ; ' '
		dec	hl

wrl4:
		ld	(de), a
		inc	de
		inc	hl
		djnz	wrl3
		cp	a
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

aphnum:					; Zistenie ci dany znak	je alfanumericky 0-9 a-z
		ld	a, (hl)
		cp	7Bh ; '{'
		ret	nc
		cp	61h ; 'a'
		jr	nc, apq
		cp	3Ah ; ':'
		ret	nc
		cp	30h ; '0'

apq:
		ccf
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

getlbl:					; Vyhladanie navestia v	tabulke	navesti
		ld	a, 17h
		ld	(jrz+1), a
		push	hl
		call	fndlbl		; Vyhladanie navestia v	tabulke	navesti
		ld	a, 28h ; '('
		ld	(jrz+1), a
		jr	c, glb2

glb1:					; Zistenie ci dany znak	je alfanumericky 0-9 a-z
		call	aphnum
		inc	hl
		jr	c, glb1
		dec	hl
		xor	a
		cp	(hl)

glb2:
		ex	de, hl
		pop	hl
		ret	c
		or	c
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

instr_asm:				; Najdenie instrukcie Z80 podla	jej nazvu
		ld	bc, insbse
		ld	d, 1

fndpsi:
		push	hl

a1:
		ld	a, (bc)
		cp	1
		jr	nc, a2
		pop	hl
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

a2:
		ld	a, (bc)
		and	7Fh ; ''
		cp	(hl)
		jr	z, ac

a3:
		ld	a, (bc)
		inc	bc
		rla
		jr	nc, a3

ax:
		pop	hl
		push	hl

a4:
		ld	a, (bc)
		inc	bc
		inc	d
		dec	d
		jr	z, a1
		inc	bc
		inc	bc
		rla
		jr	nc, a4
		jr	a1

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

ac:
		ld	a, (bc)
		inc	bc
		inc	hl
		rla
		jr	nc, a2
		ld	a, (hl)
		cp	20h ; ' '
		jr	nz, ax
		inc	sp
		inc	sp
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

getop2:
		cp	1
		jr	z, reg2

getop1:
		ld	de,  erradr+1
		ld	b, a
		and	10h
		ld	a, b
		jp	z, pgcnt	; Skok na adresu ulozenu v N-tej polozke v tabulke (A =	index polozky)
		ld	a, (hl)
		inc	hl
		cp	28h ; '('
		ld	a, b
		call	z, pgcix	; Skok na adresu ulozenu v N-tej polozke v tabulke (A bity 0-3 = index polozky)
		ret	nz
		ld	a, (hl)
		inc	hl

errhl:
		cp	29h ; ')'
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

reg2:
		ld	c, 0FFh
		jr	reg1_2

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

reg1:
		ld	c, 0

reg1_2:					; 8-bitove registre
		ld	de, regbse_7
		ld	b, 7

cl:
		ld	a, (de)
		cp	(hl)
		jr	z, ce
		dec	de
		dec	b
		jp	p, cl
		ld	a, 28h ; '('
		cp	(hl)
		jr	z, indx0
		ld	a, (code)	; Operacny kod instrukcie
		cp	70h ; 'p'
		jr	z, errhl
		call	indreg
		inc	hl
		ld	b, 4
		ld	a, (hl)
		cp	68h ; 'h'
		jr	z, ce
		inc	b
		cp	6Ch ; 'l'
		jr	z, ce
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

indx0:
		inc	hl
		ld	a, 68h ; 'h'
		cp	(hl)
		jr	nz, ci
		inc	hl
		ld	a, 6Ch ; 'l'
		cp	(hl)
		inc	hl
		ret	nz
		ld	a, (flags)
		and	0C0h ; ''
		jr	z, cc
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

ci:
		inc	a
		cp	(hl)
		ret	nz
		inc	hl
		call	indreg
		ld	b, 8
		call	stflg		; Nastavenie bitov v priznakoch
		inc	hl
		push	bc
		call	grelad
		pop	bc
		ret	nz

cc:
		ld	a, 29h ; ')'
		cp	(hl)
		ret	nz
		ld	b, 6

ce:
		inc	c
		jr	z, c2
		ld	a, b

dc:
		rlca
		rlca
		rlca
		ld	b, a

c2:
		inc	hl

c22:					; Operacny kod instrukcie
		ld	a, (code)
		add	a, b
		ld	(code),	a	; Operacny kod instrukcie
		cp	a
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

indreg:
		ld	b, 80h ; ''
		ld	a, 78h ; 'x'
		cp	(hl)
		jp	z, stflg	; Nastavenie bitov v priznakoch
		ld	b, 40h ; '@'
		inc	a
		cp	(hl)
		jp	z, stflg	; Nastavenie bitov v priznakoch
		pop	bc
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

regx:
		ld	b, 8
		ld	a, 72h ; 'r'
		cp	(hl)
		jr	z, c2
		ld	a, 69h ; 'i'
		cp	(hl)
		inc	hl
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

rest:
		ld	a, (hl)
		cp	23h ; '#'
		ret	nz
		inc	hl
		call	hxbn		; Prevod hexadecimalneho cisla na 16bit	hodnotu
		ld	b, e
		ld	a, b
		and	0C7h ; ''
		jr	z, c22
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

agreg:
		ld	de, 'af'
		jr	patrs

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

dfreg:
		ld	de, 'de'
		jr	patrs

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

spreg:
		ld	de, 'sp'

patrs:
		ld	a, (hl)
		cp	d
		ret	nz
		inc	hl
		ld	a, (hl)
		cp	e
		inc	hl
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

shcnd:
		cp	a

cond:
		push	af
		ld	b, 8
		ld	de, cdrsf	; Podmienky v podmienenych skokoch
		call	search		; Vyhladanie dvojbajtovej polozky v tabulke
		pop	af
		jr	nz, cond1
		ld	a, b
		cp	4
		ret	c

cond1:
		ld	a, 8
		sub	b
		jr	dc

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

hlreg:
		call	hlc
		inc	hl
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

pair:
		ld	de, dc
		push	de

hlc:					; 16-bitove registre
		ld	de, parbse
		ld	b, 7
		call	search		; Vyhladanie dvojbajtovej polozky v tabulke
		ld	a, (code)	; Operacny kod instrukcie
		or	0Ch
		cp	0CDh ; ''
		jr	z, pushfs
		cp	0Eh
		ld	a, b
		jr	nz, nobcde
		cp	6
		jr	c, err_x

nobcde:
		cp	3
		jr	nz, tstix

err_x:
		inc	a
		pop	bc
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

pushfs:
		ld	a, b
		cp	4
		jr	z, err_x
		cp	3
		jr	nz, tstix
		inc	b

tstix:
		dec	a
		jr	nz, tstiy
		ld	b, 40h ; '@'
		jr	ixpr

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

tstiy:
		dec	a
		jr	nz, endcu
		ld	b, 80h ; ''

ixpr:					; Nastavenie bitov v priznakoch
		call	stflg
		ld	b, 5

endcu:
		ld	a, 7
		sub	b
		rla
		cp	4
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

search:					; Vyhladanie dvojbajtovej polozky v tabulke
		ld	a, (de)
		inc	de
		cp	(hl)
		jr	nz, srch1
		ld	a, (de)
		or	a
		ret	z
		inc	hl
		cp	(hl)
		ret	z
		dec	hl

srch1:
		inc	de
		dec	b
		jr	nz, search	; Vyhladanie dvojbajtovej polozky v tabulke
		inc	b
		pop	de
		pop	de
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

creg:
		ld	a, 63h ; 'c'
		jr	areg_2

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

areg:
		ld	a, 61h ; 'a'

areg_2:
		cp	(hl)
		inc	hl
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

num:
		ld	a, 37h ; '7'
		cp	(hl)
		ret	c
		ld	a, (hl)
		sub	30h ; '0'
		ret	c
		jp	dc

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

stflg:					; Nastavenie bitov v priznakoch
		ld	a, (flags)
		or	b
		ld	(flags), a
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

pseudo:					; Najdenie pseudoinstrukcie podla jej nazvu
		inc	bc
		push	de
		ld	d, a
		call	fndpsi
		pop	de
		ret	nz
		ld	a, 0Ch
		ld	(errind), a
		ld	l, a
		ld	a, (bc)
		inc	a
		ld	(de), a
		dec	de
		ld	(nxtadr), de	; Adresa dalsej	instrukcie
		cp	0Fh
		jp	z, psq
		inc	de

gpsil:
		push	de
		ld	de, (nxtadr)	; Adresa dalsej	instrukcie
		call	gpsi
		ld	(nxtadr), de	; Adresa dalsej	instrukcie
		pop	de
		ret	nz
		ld	a, (hl)
		cp	20h ; ' '
		jp	z, psq
		cp	2Ch ; 
		inc	hl
		ret	nz
		ld	a, (de)
		and	8
		ld	a, (de)
		ret	nz
		add	a, 10h
		ld	(de), a
		jr	gpsil

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

extent:
		push	de
		call	fndlbl		; Vyhladanie navestia v	tabulke	navesti
		ld	a, c
		jp	extcnt

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

db:
		push	hl
		call	getexp
		pop	bc
		ret	z
		ld	a, (bc)
		cp	27h ; '''
		ret	nz
		inc	bc
		ld	hl, (nxtadr)	; Adresa dalsej	instrukcie
		ld	d, h
		ld	e, l
		dec	de
		ld	(hl), 80h ; ''

dbl:
		ld	a, (bc)
		inc	bc
		cp	27h ; '''
		jr	z, dbq
		ld	(de), a
		dec	de
		inc	(hl)
		jr	dbl

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

dbq:
		ld	h, b
		ld	l, c
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

word:
		ld	b, 2
		call	stflg		; Nastavenie bitov v priznakoch

_byte:
		ld	b, 4
		call	stflg		; Nastavenie bitov v priznakoch
		jr	getexp

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

gpsi:
		and	0Eh
		cp	4
		jp	m, extent
		jr	z, db

getexp:
		ld	b, 1

grelad:					; Adresa dalsej	instrukcie
		ld	de, (nxtadr)
		ld	a, (hl)
		ld	c, 10h
		cp	2Dh ; '-'
		jr	z, gv3
		cp	2Bh ; '+'
		jr	z, gv1_a
		dec	b
		ret	nz
		dec	hl

gv1_a:
		inc	hl
		ld	a, (hl)
		cp	3Ch ; '<'
		ld	c, 18h
		jr	z, gv3
		cp	3Eh ; '>'
		ld	c, 0
		jr	nz, gv2
		ld	c, 8

gv3:
		inc	hl

gv2:
		push	de
		dec	de
		call	getmem_asm	; Nacitanie jednej ciselnej hodnoty z textu a ulozenie do riadku
		jr	nz, gvend
		ld	a, c
		rlca
		rlca
		rlca
		ld	c, a
		and	0C0h ; ''
		ld	b, 0
		jr	nz, gv5
		ld	a, (hl)
		push	hl
		ld	hl, oprts_6
		ld	b, 7

gv6:
		cp	(hl)
		jr	z, gv4
		dec	hl
		djnz	gv6
		or	a

gv4:
		pop	hl
		jr	nz, gv5
		inc	hl

gv5:
		ld	a, c
		or	b
		rlca
		rlca
		ld	c, a
		ld	a, b
		or	a
		call	nz, getmem_asm	; Nacitanie jednej ciselnej hodnoty z textu a ulozenie do riadku
		ex	de, hl
		ld	(nxtadr), hl	; Adresa dalsej	instrukcie
		ex	(sp), hl
		ld	(hl), c
		pop	hl
		ex	de, hl
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

gvend:
		pop	de
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

getmem_asm:				; Nacitanie jednej ciselnej hodnoty z textu a ulozenie do riadku
		push	de
		ld	a, (hl)
		cp	27h ; '''
		jr	nz, lbl
		inc	hl
		ld	e, (hl)
		inc	hl
		cp	(hl)
		inc	hl
		jr	chrcnt

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

lbl:
		inc	c
		push	bc
		call	fndlbl		; Vyhladanie navestia v	tabulke	navesti
		ld	e, c
		pop	bc
		jr	nz, dec

chrcnt:
		ld	a, e

extcnt:
		pop	de
		ld	(de), a
		dec	de
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

dec:
		inc	c
		cp	23h ; '#'
		jr	z, hex_a
		ld	b, l
		call	dcbn		; Prevod desiatkoveho cisla na 16bit hodnotu
		jr	cnst

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

hex_a:
		inc	c
		inc	hl
		ld	b, l
		call	hxbn		; Prevod hexadecimalneho cisla na 16bit	hodnotu

cnst:
		ex	(sp), hl
		ld	(hl), e
		dec	hl
		ld	(hl), d
		dec	hl
		ex	de, hl
		pop	hl
		ld	a, b
		sub	l
		jr	z, error
		cp	a
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

error:
		inc	a
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

pgcix:					; Skok na adresu ulozenu v N-tej polozke v tabulke (A bity 0-3 = index polozky)
		and	0Fh

pgcnt:					; Skok na adresu ulozenu v N-tej polozke v tabulke (A =	index polozky)
		add	a, a
		push	hl
		ld	l, a
		ld	h, 0
		add	hl, de
		ld	e, (hl)
		inc	hl
		ld	d, (hl)
		pop	hl
		push	de

pstadr_2:
		ld	a, c
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

pstadr:		dw preg1
		dw ppair
		dw putv8		; Depak	jedneho	8-bitoveho ciselneho argumentu zo zdrojoveho textu do textoveho	buffera
		dw putv16		; Depak	jedneho	16-bitoveho ciselneho argumentu	zo zdrojoveho textu do textoveho buffera
		dw pcond
		dw pnum
		dw prest
		dw pregy
		dw pa
		dw pde
		dw phl
		dw psp
		dw paf
		dw pshcnd
		dw pc
tdolar:		db '$ '
errad:		dw 0
xy:		db 0

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

blank:					; Zmazanie textoveho buffera
		push	hl
		ld	l, 40h ; '@'
		ld	h, 0FEh	; ''

bl1:
		dec	l
		ld	(hl), 20h ; ' '
		jr	nz, bl1
		pop	hl
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

vstoas:					; Adresa labelu	 (In: C=cislo labelu  Out: DE=adresa labelu)
		push	hl
		ld	hl, (adstab)	; Adresa tabulky navesti
		ld	e, c
		xor	a
		ld	d, a
		ex	de, hl
		add	hl, hl
		add	hl, hl
		add	hl, hl
		ex	de, hl
		sbc	hl, de
		ex	de, hl
		pop	hl
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

prxdd:
		ld	a, 78h ; 'x'
		ld	(xy), a
		ld	b, 81h ; ''
		inc	hl
		ld	a, (hl)
		cp	0FDh ; ''
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

prxfd:
		ld	a, 79h ; 'y'
		ld	(xy), a
		ld	b, 41h ; 'A'
		inc	hl
		ld	a, (hl)
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

disrow:					; Disasemblovanie jednej instrukcie na adrese HL
		ld	a, 20h ; ' '
		ld	(xy), a
		ld	(nxtadr), hl	; Adresa dalsej	instrukcie
		ld	(errad), hl
		ld	b, 1
		ld	a, (hl)
		cp	0DDh ; ''
		call	z, prxdd
		jp	z, noins
		cp	0FDh ; ''
		call	z, prxfd
		cp	0EDh ; ''
		jr	nz, prxcb
		ld	a, b
		or	10h
		jr	prxcbc

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

prxcb:
		cp	0CBh ; ''
		jr	nz, woprx
		inc	a
		and	b
		jr	z, nbm
		inc	hl

nbm:
		or	21h ; '!'

prxcbc:
		ld	b, a
		inc	hl

woprx:
		ld	c, (hl)
		inc	hl
		ld	(nxtadr), hl	; Adresa dalsej	instrukcie
		ld	a, b
		and	0E0h ; ''
		jr	z, pfxok
		jp	po, pfxok
		ld	a, c
		and	7
		cp	6
		jp	nz, noins

pfxok:					; Hladanie nazvu Z80 instrukcie
		call	discnt
		ld	hl, buffer_params
		push	hl
		ld	bc, 13h
		push	bc
		ld	a, (xy)
		cpir
		pop	bc
		pop	hl
		jp	z, okins
		ld	de, buffer_params
		inc	de
		ld	(hl), 20h ; ' '
		ldir
		jp	noins

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

unpln0:					; Nacita a depakuje aktualny riadok zdrojoveho textu do	textoveho buffera
		ld	hl, (curent)

unpln:					; Nacita a depakuje riadok zdrojoveho textu do textoveho buffera
		call	blank
		call	negbc0		; Vrati	zapornu	dlzku spakovaneho riadku v zdrojovom texte
		ret	z
		ld	a, (hl)
		rla
		jr	c, un1
		dec	hl
		ld	d, h
		ld	e, l
		dec	de
		ld	a, (hl)
		inc	hl

un1:
		push	hl
		add	hl, bc
		ex	(sp), hl
		ld	bc, buffer	; Textovy buffer pre jeden riadok na obrazovke
		inc	a
		jr	z, unc
		call	upmain		; Vypis	navestia a nazvu instrukcie
		ld	de, (nxtadr)	; Adresa dalsej	instrukcie
		ld	bc, buffer_comment

unc:
		pop	hl

unc1:					; Porovnanie HL	a DE
		call	cmhlde
		ret	z
		ld	a, (de)
		ld	(bc), a
		dec	de
		inc	bc
		jr	unc1

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

upmain:					; Vypis	navestia a nazvu instrukcie
		ld	a, (hl)
		rlca
		dec	hl
		jr	nc, pwolbl
		ld	c, (hl)
		dec	hl
		push	hl
		ld	hl, buffer	; Textovy buffer pre jeden riadok na obrazovke
		call	outlab		; Vypis	navestia do buffera
		pop	hl

pwolbl:
		ld	b, (hl)
		dec	hl
		ld	a, b
		scf
		rra
		inc	a
		jr	z, psd
		jr	c, psd
		ld	c, (hl)
		dec	hl

psd:					; Adresa dalsej	instrukcie
		ld	(nxtadr), hl
		ret	z
		jr	c, ppseud	; Hladanie nazvu pseudoinstrukcie

discnt:					; Hladanie nazvu Z80 instrukcie
		ld	hl, insbse

loop2:
		push	hl

fnd1:
		ld	a, (hl)
		rla
		inc	hl
		jr	nc, fnd1

loop3:
		push	hl
		ld	a, (hl)
		call	getms1		; Nacitanie N-teho bajtu z tabulky mstab
		ld	d, a
		inc	hl
		ld	a, (hl)
		call	getms2		; Nacitanie N-teho bajtu z tabulky mstab (Pre N=1 vratri #F8)
		and	d
		and	c
		inc	hl
		cp	(hl)
		pop	de
		jr	nz, cddif
		ld	a, (de)
		rra
		xor	b
		and	30h ; '0'
		jr	z, isamf

cddif:
		inc	hl
		ld	a, (de)
		rla
		jr	nc, loop3
		pop	af
		ld	a, (hl)
		and	a
		jr	nz, loop2

noins:
		ld	hl, (errad)
		ld	a, (hl)
		inc	hl
		ld	(nxtadr), hl	; Adresa dalsej	instrukcie
		ld	hl, buffer_instr
		ld	(hl), 64h ; 'd'
		inc	hl
		ld	(hl), 62h ; 'b'
		inc	hl
		ld	(hl), 20h ; ' '
		inc	hl
		ld	(hl), 20h ; ' '
		inc	hl
		ld	(hl), 23h ; '#'
		inc	hl
		call	bnhx		; Prevod 8bit hodnoty na hexadecimalne cislo

okins:					; Adresa dalsej	instrukcie
		ld	hl, (nxtadr)
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

ppseud:					; Hladanie nazvu pseudoinstrukcie
		ld	hl, psibse

tstant:
		push	hl

skname:
		ld	a, (hl)
		rla
		inc	hl
		jr	nc, skname
		pop	de
		ld	a, b
		and	0FEh ; ''
		ld	b, a
		and	0Fh
		cp	(hl)
		inc	hl
		jr	nz, tstant
		push	bc
		ex	de, hl
		call	outnam_asm	; Prekopirovanie nazvu instrukcie do pola instrukcie v textovom	bufferi
		pop	af

ppsil:
		push	af
		ld	de, (nxtadr)	; Adresa dalsej	instrukcie
		call	ppsi
		ld	(nxtadr), de	; Adresa dalsej	instrukcie
		pop	af
		sub	10h
		ret	c
		ld	(hl), 2Ch ; 
		inc	hl
		jr	ppsil

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

ppsi:
		and	0Fh
		cp	4
		jp	c, pentex	; Depak	jedneho	navestia
		cp	0Eh
		ret	nc
		ld	a, (de)
		ld	c, a
		add	a, a
		jp	nc, q11
		dec	de
		ld	(hl), 27h ; '''

pstrl:
		inc	hl
		dec	c
		jp	p, pstrq
		ld	a, (de)
		dec	de
		ld	(hl), a
		jr	pstrl

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

pstrq:
		ld	(hl), 27h ; '''
		inc	hl
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

isamf:
		ex	de, hl
		ex	(sp), hl
		call	outnam_asm	; Prekopirovanie nazvu instrukcie do pola instrukcie v textovom	bufferi
		pop	de
		ld	a, b
		and	0C0h ; ''
		jr	z, okpref
		inc	de
		ld	a, (de)
		dec	de
		dec	a
		cp	2
		jr	c, okpref
		cp	0Ah
		jr	z, okpref
		ld	a, (de)
		and	0Fh
		dec	a
		cp	0Ah
		jr	z, okpref
		cp	2
		jp	nc, noins

okpref:
		ld	a, (de)
		inc	de
		and	1Fh
		jr	z, wo1op
		push	de
		push	bc
		call	putop1		; Vypis	parametra instrukcie
		pop	bc
		pop	de
		ld	a, (de)
		and	a
		ret	z
		ld	(hl), 2Ch ; 
		inc	hl

wo1op:
		ld	a, (de)
		and	a
		ret	z

putop2:
		cp	1
		jr	z, preg2

putop1:					; Vypis	parametra instrukcie
		ld	de, pstadr_2
		push	bc
		ld	b, a
		and	10h
		ld	a, b
		pop	bc
		jp	z, pgcnt	; Skok na adresu ulozenu v N-tej polozke v tabulke (A =	index polozky)

hlcnt:
		ld	(hl), 28h ; '('
		inc	hl
		call	pgcix		; Skok na adresu ulozenu v N-tej polozke v tabulke (A bity 0-3 = index polozky)

hlcnti:
		ld	(hl), 29h ; ')'
		inc	hl
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

outnam_asm:				; Prekopirovanie nazvu instrukcie do pola instrukcie v textovom	bufferi
		push	bc
		ld	de, buffer_instr

onl:
		ldi
		ld	a, (hl)
		rla
		jr	nc, onl
		ccf
		rra
		ld	(de), a
		ld	hl, buffer_params
		pop	bc
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

pc:
		ld	(hl), 63h ; 'c'
		inc	hl
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

pa:
		ld	a, 38h ; '8'

preg1:
		rrca
		rrca
		rrca
		ld	c, a

preg2:
		ld	a, c
		and	7
		cp	6
		jr	nz, rg1
		push	bc
		ld	a, 1Bh
		call	putop1		; Vypis	parametra instrukcie
		pop	bc
		ld	a, b
		and	0C0h ; ''
		ret	z
		dec	hl
		ld	a, b
		and	21h ; '!'
		cp	21h ; '!'
		jr	z, pxc8
		ld	c, 0FFh
		call	putv8		; Depak	jedneho	8-bitoveho ciselneho argumentu zo zdrojoveho textu do textoveho	buffera
		jr	hlcnti

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

pxc8:
		push	hl
		ld	hl, (nxtadr)	; Adresa dalsej	instrukcie
		dec	hl
		dec	hl
		ld	a, (hl)
		pop	hl
		ld	(hl), 2Bh ; '+'
		inc	hl
		ld	(hl), 23h ; '#'
		inc	hl
		call	bnhx		; Prevod 8bit hodnoty na hexadecimalne cislo
		jr	hlcnti

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

rg1:
		cp	7
		jr	z, rg2
		cp	4
		jr	c, rg2
		ld	(hl), 78h ; 'x'
		bit	7, b
		jr	nz, rg3
		ld	(hl), 79h ; 'y'
		bit	6, b
		jr	z, rg2

rg3:
		bit	3, b
		jr	nz, rg2
		ld	a, c
		sub	74h ; 't'
		jr	z, rg4
		dec	a
		jr	z, rg4
		sub	57h ; 'W'
		jr	z, rg4
		dec	a
		jr	z, rg4
		inc	hl

rg4:
		ld	a, c
		and	7

rg2:
		add	a, 0EBh	; ''
		ld	e, a
		ld	a, 0
		adc	a, 0E0h	; ''
		ld	d, a
		ld	a, (de)
		ld	(hl), a
		inc	hl
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

pde:
		ld	c, 2
		jr	pr3

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

psp:
		ld	c, 6
		jr	pr3

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

paf:
		ld	c, 8
		jr	pr3

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

phl:
		ld	c, 20h ; ' '
		ld	a, c

ppair:
		or	8
		cp	3Ah ; ':'
		jr	z, putv16	; Depak	jedneho	16-bitoveho ciselneho argumentu	zo zdrojoveho textu do textoveho buffera
		ld	a, c
		rra
		rra
		rra
		and	6
		cp	6
		jr	nz, pr1
		ld	b, a
		ld	a, c
		or	4
		cp	0F5h ; ''
		ld	c, b
		jr	z, pr2
		jr	pr3

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

pr1:
		cp	4
		ld	c, a
		jr	nz, pr3
		ld	c, 0Ah
		ld	a, b
		and	80h ; ''
		jr	nz, pr3
		ld	a, b
		and	40h ; '@'
		jr	nz, pr2
		ld	c, 2

pr2:
		inc	c
		inc	c

pr3:
		ld	a, c
		add	a, 0F3h	; ''
		ld	c, a
		ld	a, 0
		adc	a, 0E0h	; ''
		ld	b, a
		ld	a, (bc)
		ld	(hl), a
		inc	hl
		inc	bc
		ld	a, (bc)
		and	a
		ret	z
		ld	(hl), a
		inc	hl
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

pshcnd:
		and	18h

pcond:
		and	38h ; '8'
		rra
		rra
		add	a, 0Eh
		ld	c, a
		jr	pr3

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

pregy:
		ld	(hl), 69h ; 'i'
		inc	hl
		and	8
		ret	z
		dec	hl
		ld	(hl), 72h ; 'r'
		inc	hl
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

pnum:
		rra
		rra
		rra
		and	7
		add	a, 30h ; '0'
		ld	(hl), a
		inc	hl
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

getms2:					; Nacitanie N-teho bajtu z tabulky mstab (Pre N=1 vratri #F8)
		cp	1
		jr	nz, getms1	; Nacitanie N-teho bajtu z tabulky mstab
		ld	a, 0F8h	; ''
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

getms1:					; Nacitanie N-teho bajtu z tabulky mstab
		and	0Fh
		push	de
		add	a, 11h		; low mstab
		ld	e, a
		ld	a, 0
		adc	a, 0E1h	; ''   ; high mstab
		ld	d, a
		ld	a, (de)
		pop	de
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

putv8:					; Depak	jedneho	8-bitoveho ciselneho argumentu zo zdrojoveho textu do textoveho	buffera
		ld	a, b
		and	1
		jr	q11

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

putv16:					; Depak	jedneho	16-bitoveho ciselneho argumentu	zo zdrojoveho textu do textoveho buffera
		ld	a, b
		and	1
		or	2

q11:
		ld	b, a
		ld	de, (nxtadr)	; Adresa dalsej	instrukcie
		ld	a, b
		rra
		jr	nc, unpc
		rra
		ld	a, (de)
		inc	de
		ld	(hl), 2Bh ; '+'
		inc	c
		jr	nz, q12
		inc	hl

q12:
		ld	(hl), 23h ; '#'
		inc	hl
		jr	nc, q33
		ld	b, a
		ld	a, (de)
		inc	de
		call	bnhx		; Prevod 8bit hodnoty na hexadecimalne cislo
		ld	a, b

q33:					; Prevod 8bit hodnoty na hexadecimalne cislo
		call	bnhx
		jr	pvq

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

unpc:
		ld	a, (de)
		and	1Fh
		cp	2
		ld	(hl), 2Dh ; '-'
		jr	z, pv1_a
		inc	c
		jr	nz, pv2
		ld	(hl), 2Bh ; '+'
		inc	hl

pv2:
		dec	a
		ld	(hl), 3Eh ; '>'
		jr	z, pv1_a
		sub	2
		ld	(hl), 3Ch ; '<'
		jr	nz, pv3

pv1_a:
		inc	hl

pv3:
		ld	a, (de)
		push	af
		dec	de
		rlca
		rlca
		rlca
		call	putmem		; Depak	jednej ciselnej	hodnoty	zo zdrojoveho textu do textoveho buffera
		pop	af
		ld	c, a
		rrca
		rrca
		and	7
		jr	z, pvq
		push	hl
		ld	l, a
		ld	a, c
		ld	h, 0
		ld	bc, lastlb
		add	hl, bc
		ld	c, (hl)
		pop	hl
		ld	(hl), c
		inc	hl
		call	putmem		; Depak	jednej ciselnej	hodnoty	zo zdrojoveho textu do textoveho buffera

pvq:					; Adresa dalsej	instrukcie
		ld	(nxtadr), de
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

pentex:					; Depak	jedneho	navestia
		ld	a, 1

putmem:					; Depak	jednej ciselnej	hodnoty	zo zdrojoveho textu do textoveho buffera
		and	3
		ex	de, hl
		ld	c, (hl)
		dec	hl
		ex	de, hl
		jr	nz, pm1
		ld	(hl), 27h ; '''
		inc	hl
		ld	(hl), c
		inc	hl
		ld	(hl), 27h ; '''
		inc	hl
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

pm1:
		dec	a
		jr	nz, pm2

outlab:					; Vypis	navestia do buffera
		push	de
		ld	a, c
		or	a
		ld	de, tdolar
		call	nz, vstoas	; Adresa labelu	 (In: C=cislo labelu  Out: DE=adresa labelu)
		ld	b, 6

ol1:
		ld	a, (de)
		and	7Fh ; ''
		ld	(hl), a
		cp	20h ; ' '
		jr	z, ol2
		inc	hl
		inc	de
		djnz	ol1

ol2:
		pop	de
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

pm2:
		dec	a
		ld	a, (de)
		ld	b, a
		dec	de
		jr	nz, bin
		push	de
		call	bndc		; Prevod 16bit hodnoty na desiatkove cislo
		pop	de
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

bin:
		ld	(hl), '#'
		inc	hl
		or	a
		call	nz, bnhx	; Prevod 8bit hodnoty na hexadecimalne cislo
		ld	a, c
		jp	bnhx		; Prevod 8bit hodnoty na hexadecimalne cislo

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

prest:
		and	38h ; '8'
		ld	(hl), '#'
		inc	hl
		jp	bnhx		; Prevod 8bit hodnoty na hexadecimalne cislo

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;   bndc   - konverzia 16-bitovej hodnoty na retazec decimalnych cislic
;	     vstup:  <bc> = konvertovane cislo
;		     <hl> = adresa pamati, kde sa ma vysledok ulozit
;	     vystup: <hl> = adresa pamati, za retazcom decimalnych cislic
;	     cislo je ulozene v	pamati ako retazec ascii znakov, predradene 0 sa vypustia
;	     meni sa:  <af>, <bc>, <de>, <hl>

bndc:					; Prevod 16bit hodnoty na desiatkove cislo
		ld	a, 1

bd0:
		ld	d, b
		ld	e, c
		ld	c, a
		ex	de, hl
		push	bc

bd1:
		xor	a
		ld	b, 10h

bd2:
		add	hl, hl
		adc	a, a
		cp	0Ah
		jr	c, bd3
		sub	0Ah
		inc	l

bd3:
		dec	b
		jr	nz, bd2
		or	30h ; '0'
		push	af
		ld	a, l
		or	h
		jr	nz, bd1
		ex	de, hl
		inc	a
		cp	c
		sbc	a, a
		ld	b, a

bd4:
		pop	af
		ret	c
		ld	(hl), a
		add	hl, bc
		jr	bd4

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

bnhx2:					; Prevod 16bit hodnoty na hexadecimalne	cislo
		ld	a, d
		call	bnhx		; Prevod 8bit hodnoty na hexadecimalne cislo
		ld	a, e

;   bnhx   - konverzia 8-bitovej hodnoty na dve	hexadecimalne cislice
;	     vstup:  <a> = konvertovane	cislo
;		     <hl> = adresa pamati, kde sa ma vysledok konverzie	ulozit
;	     vystup: <hl> = adresa pamati za ulozenou dvojicou znakov
;	     meni sa:  <af>, <hl>

bnhx:					; Prevod 8bit hodnoty na hexadecimalne cislo
		push	af
		rrca
		rrca
		rrca
		rrca
		call	bnhx1
		pop	af

bnhx1:
		and	0Fh
		add	a, 90h ; ''
		daa
		adc	a, 40h ; '@'
		daa
		or	20h ; ' '

dnum:
		ld	(hl), a
		inc	hl
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;   hxbn   - konverzia retazca hexadecimalnych cislic na 16-bitovu binarnu hodnotu.
;	     vstup:  <hl> = adresa retazca
;	     vystup: <hl> = adresa konca retazca (retazec konci	lubovolnym symbolom mimo cislic	0-9 a pismen a-f.
;		     <de> = konvertovana binarna hodnota
;	     meni sa:  <af>, <de>, <hl>

hxbn:					; Prevod hexadecimalneho cisla na 16bit	hodnotu
		ld	de, 0

hxbn_3:
		ld	a, (hl)
		call	hxbn1		; Zistenie hodnoty jednej hexadecimalnej cislice
		ret	c
		ex	de, hl
		add	hl, hl
		add	hl, hl
		add	hl, hl
		add	hl, hl
		ex	de, hl
		or	e
		ld	e, a
		inc	hl
		jr	hxbn_3

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

hxbn1:					; Zistenie hodnoty jednej hexadecimalnej cislice
		add	a, -3Ah
		jr	c, hxbn2
		sub	-0Ah
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

hxbn2:
		and	0DFh ; ''
		sub	7
		ret	c
		add	a, -6
		ret	c
		sub	-10h
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;   dcbn   - konverzia retazca decimalnych cislic na 16-bitovu binarnu hodnotu
;	     vstup:  <hl> = adresa retazca
;	     vystup: <hl> = adresa konca retazca (retazec konci	lubovolnym symbolom mimo cislic	0-9.
;		     <de> = konvertovana binarna hodnota
;		     <a>  = ukoncovaci znak
;	     meni sa:  <af>, <de>, <hl>

dcbn:					; Prevod desiatkoveho cisla na 16bit hodnotu
		ld	de, 0

dcbn_3:
		ld	a, (hl)
		cp	3Ah ; ':'
		ret	nc
		sub	30h ; '0'
		ret	c
		ex	de, hl
		push	bc
		add	hl, hl
		ld	b, h
		ld	c, l
		add	hl, hl
		add	hl, hl
		add	hl, bc
		ld	c, a
		ld	b, 0
		add	hl, bc
		pop	bc
		ex	de, hl
		inc	hl
		jr	dcbn_3

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

blkbdb:					; Zmazanie spodneho riadku obrazovky
		ld	hl, 50C0h

blvst:
		ld	a, 20h ; ' '
		call	pixel		; Vykreslenie jedneho znaku na obrazovku (A = ascii kod, DE = pozicia vo videoram)
		inc	l
		jr	nz, blvst
		ld	hl, (poscur)	; Aktualna pohoha blikajuceho atributu na obrazovke
		res	7, (hl)
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

vstup:					; Zadanie jednej hodnoty
		call	blkbdb
		ld	b, 3
		ld	de, 0
		ld	h, 0FEh	; ''
		inc	b
		ld	l, b
		ld	(hl), 3Ah ; ':'
		inc	b
		ld	l, 0
		ld	c, 1
		ld	a, b
		ld	(vst+1), a
		xor	a
		call	mrsin		; Praca	s nezmazanym dialogovym	riadkom

vst:
		ld	l, 0
		ld	h, 0FEh	; ''
		ld	a, (hl)
		or	a
		ret	z
		ld	de, 0
		ld	a, 5Ah ; 'Z'

vst0:
		ld	(retvst+1), de
		ld	(adcsbc+1), a
		ld	a, (hl)
		cp	23h ; '#'
		jr	z, hex_b
		cp	3Ah ; ':'
		jr	nc, nav
		call	dcbn		; Prevod desiatkoveho cisla na 16bit hodnotu
		jr	exvst

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

hex_b:
		inc	hl
		call	hxbn		; Prevod hexadecimalneho cisla na 16bit	hodnotu

exvst:
		push	hl

retvst:
		ld	hl, 0
		or	a

adcsbc:
		adc	hl, de
		ex	de, hl
		pop	hl
		ld	a, (hl)
		or	a
		jr	nz, exv1
		inc	a
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

exv1:
		cp	2Bh ; '+'
		ld	a, 5Ah ; 'Z'
		jr	z, vst1
		ld	a, (hl)
		cp	2Dh ; '-'
		ld	a, 52h ; 'R'

vst1:
		inc	hl
		jr	z, vst0
		jp	mrs2		; Oprava textu zadaneho	v module "mrs"

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

nav:					; Vyhladanie navestia v	tabulke	navesti
		call	getlbl
		push	de
		xor	a
		or	c
		jr	z, sche
		call	vstoax		; Adresa labelu	 (In: C=cislo labelu  Out: HL=adresa labelu)
		push	hl
		inc	hl
		inc	hl
		inc	hl
		bit	7, (hl)
		pop	hl
		jr	nz, sche
		bit	7, (hl)
		jr	nz, nval

sche:					; Vyhladanie vstupneho bodu v kniznici
		call	schent
		jp	z, mrs3

nval:
		ld	de, 6
		add	hl, de
		ld	e, (hl)
		inc	hl
		ld	d, (hl)
		jr	retvst

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

outbdb:					; Vypis	buffera	na spodny riadok obrazovky
		ld	hl, 50C0h
		ld	de, buffer	; Textovy buffer pre jeden riadok na obrazovke

loutb:					; Vypis	zadaneho textu a zmazanie kurzora
		ld	a, (de)
		call	pixel		; Vykreslenie jedneho znaku na obrazovku (A = ascii kod, DE = pozicia vo videoram)
		inc	e
		inc	l
		jr	nz, loutb	; Vypis	zadaneho textu a zmazanie kurzora
		ld	hl, (poscur)	; Aktualna pohoha blikajuceho atributu na obrazovke
		res	7, (hl)
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

clrd:					; Zmazanie textoveho buffera
		ld	hl, buffer_end

clrd1:
		ld	(hl), 20h ; ' '
		dec	l
		jr	nz, clrd1
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

dwhx:					; Vypis	hexadecimalnej hodnoty z pameti
		ld	a, (de)
		push	af
		inc	de
		ld	a, (de)
		call	bnhx		; Prevod 8bit hodnoty na hexadecimalne cislo
		pop	af
		inc	de
		jp	bnhx		; Prevod 8bit hodnoty na hexadecimalne cislo

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

dump1r:					; Vypis	styroch	bajtov pamete pre dump a modify
		push	hl
		push	bc
		call	clrd		; Zmazanie textoveho buffera
		ld	a, d
		call	bnhx		; Prevod 8bit hodnoty na hexadecimalne cislo
		ld	a, e
		call	bnhx		; Prevod 8bit hodnoty na hexadecimalne cislo
		ld	(hl), 3Ah ; ':'
		inc	hl
		inc	hl
		push	de
		ld	b, 4

d1r1:
		ld	a, (de)
		call	bnhx		; Prevod 8bit hodnoty na hexadecimalne cislo
		inc	hl
		inc	de
		djnz	d1r1
		ld	(hl), 3Ah ; ':'
		pop	de
		inc	hl
		ld	b, 4

d1r2:
		ld	a, (de)
		cp	20h ; ' '
		jr	c, d1r3
		cp	7Fh ; ''
		jr	c, d1r4

d1r3:
		ld	a, 2Eh ; '.'

d1r4:
		ld	(hl), a
		inc	hl
		inc	de
		djnz	d1r2
		pop	bc
		pop	hl
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

modify:					; Debugger klavesa M - modifikacia obsahu pameti
		ld	hl,  mod1+1
		call	reg02		; Zadanie jednej hodnoty a jej ulozenie	na (HL)

mod1:
		ld	de, 0

mod2:
		ld	l, 6

mod0:
		push	de
		call	dump1r		; Vypis	styroch	bajtov pamete pre dump a modify
		pop	de

modnew:					; Vypis	buffera	na spodny riadok obrazovky
		call	outdlg
		ld	h, 16h
		call	setcrs		; Zmazanie kurzora na starej a zobrazenie na novej pozicii
		ld	h, 0FEh	; ''

mod3:					; ; Obsluha klavesnice s autorepeatom
		call	inkey
		cp	7
		jr	z, mod2
		ld	bc, 5
		push	hl
		ld	hl, tabmf	; Klavesy pre pohyby po	pameti v prikaze Modify
		cpir
		add	hl, bc
		add	hl, bc
		ld	c, (hl)
		pop	hl
		jr	z, modd
		cp	20h ; ' '
		jr	nz, mod4
		dec	l
		cp	(hl)
		inc	l
		jr	c, mod5
		call	inkey		; ; Obsluha klavesnice s autorepeatom
		call	bnhx		; Prevod 8bit hodnoty na hexadecimalne cislo
		jr	modd

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

mod4:
		ld	b, a
		call	hxbn1		; Zistenie hodnoty jednej hexadecimalnej cislice

mod5:					; Vyraznejsi zvukovy signal so zachovanim AF
		call	c, beep
		jr	c, mod3

mod7:
		ld	(hl), b

modd:
		ld	a, c
		rlca
		sbc	a, a
		ld	b, a
		bit	0, c
		jr	z, mod9

mod8:
		add	hl, bc
		ld	a, (hl)
		cp	20h ; ' '
		jr	z, mod8
		cp	3Ah ; ':'
		jr	nz, modnew

mod9:
		push	de
		ld	l, 6

mod10:
		push	de
		call	hxbn		; Prevod hexadecimalneho cisla na 16bit	hodnotu
		ld	a, e
		pop	de
		ld	(de), a
		inc	de
		inc	l
		ld	a, (hl)
		cp	3Ah ; ':'
		jr	nz, mod10
		pop	hl
		add	hl, bc
		ex	de, hl
		ld	l, 0Fh
		dec	c
		jp	z, mod0
		inc	c
		jp	nz, mod2
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

tabmf:		db  1Eh			; Klavesy pre pohyby po	pameti v prikaze Modify
		db  1Dh
		db  0Dh
		db  19h
		db  18h

		db    1			; Prirastky adresy pre jednotlive pohyby
		db 0FFh
		db    0
		db    4
		db 0FCh

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

window:					; Zistenie ci HL padne do jedneho zo styroch okien definovanych	na adrese DE
		ld	a, 7

window_2:				; Zistenie ci HL padne do okna definovaneho na adrese DE
		call	compar
		jr	z, wind0
		jr	nc, wind1
		call	compar		; Porovnanie hodnoty HL	s wordom na adrese DE
		jr	c, wind2

wind0:
		scf
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

wind1:
		dec	de
		dec	de

wind2:
		rrca
		jr	c, window_2	; Zistenie ci HL padne do okna definovaneho na adrese DE
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

compar:					; Porovnanie hodnoty HL	s wordom na adrese DE
		push	bc
		ex	de, hl
		ld	b, (hl)
		dec	hl
		ld	c, (hl)
		dec	hl
		ex	de, hl
		push	hl
		or	a
		sbc	hl, bc
		pop	hl
		pop	bc
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

hard:					; Kontrola zadaneho prikazu v debuggeri
		ld	a, (zac+1)
		cp	4Ah ; 'J'
		scf
		ret	z
		cp	61h ; 'a'
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

wmem:					; Zistenie ci adresa na	ktoru sa ma zapisovat nie je v niektorom pametovom okne
		push	de
		ld	de,  wm2+0Dh
		call	window		; Zistenie ci HL padne do jedneho zo styroch okien definovanych	na adrese DE
		pop	de
		jr	nc, wmem2
		call	hard		; Kontrola zadaneho prikazu v debuggeri
		ld	a, 4Dh ; 'M'

wmem1:					; Vyraznejsi zvukovy signal so zachovanim AF
		call	nc, beep
		jp	nc, errtxt	; Pracovny priestor pre	stack

wmem2:
		push	de
		ld	de,  prtadr_2+1
		xor	a
		call	window_2	; Zistenie ci HL padne do okna definovaneho na adrese DE
		pop	de
		ret	nc
		ld	a, 2Eh ; '.'
		ld	(wmm), a
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

wpc:					; Zistenie ci adresa vykonavaneho programu je v	niektorom pametovom okne
		push	de
		ld	de,  countr+0Fh	; Hranice pre PC okna
		call	window		; Zistenie ci HL padne do jedneho zo styroch okien definovanych	na adrese DE
		pop	de
		ret	c
		call	hard		; Kontrola zadaneho prikazu v debuggeri
		ld	a, 50h ; 'P'
		jr	nc, wmem1
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

dumplr:					; Vypis	L riadkov dumpu	pamete pre prikaz Dump
		ld	h, 0

dumpl1:					; Vypis	styroch	bajtov pamete pre dump a modify
		call	dump1r
		call	outbuf		; Vypis	textoveho buffera na dany riadok obrazovky
		inc	h
		dec	l
		jr	nz, dumpl1
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

anti:					; Debugger klavesa A - disasembler - vypise strojovy kod od danej adresy
		ld	hl,  an2+1
		call	reg02		; Zadanie jednej hodnoty a jej ulozenie	na (HL)

an1:					; Zmazanie obrazovky
		call	clear

an2:
		ld	de, 0
		ld	b, 16h

an3:
		push	bc
		call	clrd		; Zmazanie textoveho buffera
		ld	a, d
		call	bnhx		; Prevod 8bit hodnoty na hexadecimalne cislo
		ld	a, e
		call	bnhx		; Prevod 8bit hodnoty na hexadecimalne cislo
		ex	de, hl
		call	disrow		; Disasemblovanie jednej instrukcie na adrese HL
		ex	de, hl
		xor	a
		call	rolup1		; Posun	casti obrazovky	o jeden	riadok hore
		push	hl
		ld	h, 15h
		ld	l, 0
		call	outbuf		; Vypis	textoveho buffera na dany riadok obrazovky
		pop	hl
		pop	bc
		djnz	an3
		inc	b

an4:					; ; Obsluha klavesnice s autorepeatom
		call	inkey
		cp	61h ; 'a'
		jr	z, an3
		cp	0Dh
		call	nz, beep	; Vyraznejsi zvukovy signal so zachovanim AF
		jr	nz, an4
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

dump:					; Debugger klavesa D - vypis pameti a hladanie bajtov/textov v pameti
		ld	hl,  dump1+1
		call	reg02		; Zadanie jednej hodnoty a jej ulozenie	na (HL)

dump0:					; Zmazanie obrazovky
		call	clear

dump1:
		ld	de, 0

dump2:
		push	de
		ld	l, 10h
		call	dumplr		; Vypis	L riadkov dumpu	pamete pre prikaz Dump
		pop	de

dump3:					; Zmazanie spodneho riadku obrazovky
		call	blkbdb
		call	inkey		; ; Obsluha klavesnice s autorepeatom
		cp	0Dh
		ret	z
		call	dumpp		; Ovladacie klavesy pre	zmeny adresy dumpu
		call	nz, beep	; Vyraznejsi zvukovy signal so zachovanim AF
		jr	nz, dump3
		add	hl, de
		ex	de, hl
		jr	dump2

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

dumpp:					; Ovladacie klavesy pre	zmeny adresy dumpu
		ld	hl, 40h
		cp	1Ah
		ret	z
		ld	hl, -40h
		cp	17h
		ret	z
		ld	c, 0
		cp	61h ; 'a'
		jr	z, paket
		ld	c, 2
		cp	68h ; 'h'
		ret	nz

paket:					; Zmazanie textoveho buffera
		call	clrd
		ld	(hl), a
		inc	hl
		ld	(hl), 3Ah ; ':'
		inc	hl

err_ret:				; Vyraznejsi zvukovy signal so zachovanim AF
		call	c, beep
		ld	(hl), 20h ; ' '
		push	hl
		ld	h, 16h
		call	setcrs		; Zmazanie kurzora na starej a zobrazenie na novej pozicii
		call	outdlg		; Vypis	buffera	na spodny riadok obrazovky
		ld	hl, err_ret
		ex	(sp), hl
		call	inkey		; ; Obsluha klavesnice s autorepeatom
		cp	0Dh
		jr	nz, pt1

ptfnc:
		ld	a, c
		rrca
		ret	c
		pop	af
		ld	a, l
		cp	3
		jr	nc, ptf0
		ld	a, (ptfb+1)
		ld	c, a
		ld	b, 0
		dec	bc
		dec	bc
		ld	hl, buffer_2
		push	de
		ex	de, hl
		ldir
		pop	de

ptf0:
		bit	1, c
		jr	z, ptf2
		push	de
		ld	l, 2
		ld	b, h
		ld	c, l

ptf1:					; Prevod hexadecimalneho cisla na 16bit	hodnotu
		call	hxbn
		ld	a, e
		ld	(bc), a
		inc	bc
		inc	hl
		ld	a, (hl)
		cp	20h ; ' '
		jr	nz, ptf1
		pop	de
		ld	a, c

ptf2:
		ld	(ptfb+1), a
		ld	bc, -1

ptf3:
		ld	hl, buffer_2
		inc	de
		ld	a, (hl)
		ex	de, hl
		cpir
		ex	de, hl
		ret	nz
		dec	de
		push	de

ptf4:
		ld	a, (de)
		cp	(hl)
		jr	nz, ptf6
		inc	de
		inc	l
		ld	a, l

ptfb:
		sub	3
		jr	nz, ptf4
		sbc	hl, de
		jr	z, ptf5
		inc	a

ptf5:
		dec	a

ptf6:
		pop	de
		jr	nz, ptf3
		ld	h, a
		ld	l, a
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

pt1:
		cp	13h
		jr	nz, pt2
		ld	a, l
		cp	3
		ret	c
		dec	l
		ld	a, c
		or	a
		ret	z
		xor	1
		ld	c, a
		ret	po
		dec	l
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

pt2:
		cp	20h ; ' '
		ret	c
		ld	b, a
		bit	1, c
		call	nz, hxbn1	; Zistenie hodnoty jednej hexadecimalnej cislice
		ret	c
		ld	(hl), b
		ld	a, 1Bh
		cp	l
		ret	c
		inc	l
		ld	a, c
		or	a
		ret	z
		xor	1
		ld	c, a
		ret	pe
		inc	l
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

tbflag:		db  40h	; @
		db    1
		db    4
		db  80h	; 
tflg:		db 'SZAPC'  ; Priznaky pre ich vypis v debuggeri

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

quit:					; Debugger klavesa Q - ukoncenie debuggera
		call	blkbdb
		ld	sp, (stack)	; Hodnota SP pri spusteni systemu MRS
		jp	monit		; Vstup	do modulu "mrs>"

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

regist:					; Debugger klavesa R - nastavenie registrov
		call	inkey
		and	0DFh ; ''
		ld	(hl), a
		cp	50h ; 'P'
		jr	nz, reg00	; Zadanie hodnoty pre 16-bit register
		ld	hl, oebrpc
		ex	(sp), hl
		ld	hl, rpc		; Hodnota registra PC v	debuggeri
		jr	reg02		; Zadanie jednej hodnoty a jej ulozenie	na (HL)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

reg00:					; Zadanie hodnoty pre 16-bit register
		ld	hl,  tabreg+6
		ld	bc, 7
		cpdr
		ret	nz
		ld	hl,  raf+1	; Hodnota registra AF v	debuggeri
		add	hl, bc
		add	hl, bc
		add	hl, bc
		add	hl, bc

reg02:					; Zadanie jednej hodnoty a jej ulozenie	na (HL)
		push	hl
		call	vstup		; Zadanie jednej hodnoty
		pop	hl
		ret	z
		ld	(hl), e
		inc	hl
		ld	(hl), d
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

tabreg:		db 'ABDHXYS' ; 16-bitove registre pre zadavanie ich hodnot

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

wmpc:					; Debugger klavesa W - nastavenie PC a memory okien
		call	inkey
		and	0DFh ; ''
		ld	(hl), a
		ld	de, wm		; Hranice pre pametove okna
		cp	4Dh ; 'M'
		jr	z, wpm0
		cp	50h ; 'P'
		jp	nz, beep	; Vyraznejsi zvukovy signal so zachovanim AF
		ld	de, countr	; Hranice pre PC okna

wpm0:
		push	de
		push	af
		ld	bc, 831h
		inc	hl
		inc	hl

wpm1:
		ld	(hl), c
		inc	hl
		ld	(hl), 3Ah ; ':'
		inc	hl
		call	dwhx		; Vypis	hexadecimalnej hodnoty z pameti
		ld	a, b
		rrca
		jr	nc, wpm2
		inc	hl
		inc	hl

wpm2:
		inc	hl
		inc	c
		djnz	wpm1
		call	outdlg		; Vypis	buffera	na spodny riadok obrazovky
		call	clrd		; Zmazanie textoveho buffera
		ld	b, l
		inc	hl
		pop	af
		ld	(hl), a
		inc	hl
		call	inkey		; ; Obsluha klavesnice s autorepeatom
		ld	(hl), a
		pop	hl
		sub	31h ; '1'
		jp	c, beep		; Vyraznejsi zvukovy signal so zachovanim AF
		cp	8
		jp	nc, beep	; Vyraznejsi zvukovy signal so zachovanim AF
		ld	c, a
		add	hl, bc
		add	hl, bc
		jr	reg02		; Zadanie jednej hodnoty a jej ulozenie	na (HL)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

print:					; Debugger klavesa P - zobrazenie zadanej oblasti pamete pri zapise do nej
		call	vstup
		jr	z, print1
		ld	(prtadr), de

print1:					; Zmazanie textoveho buffera
		call	clrd
		ld	(hl), 4Ch ; 'L'
		call	vstup		; Zadanie jednej hodnoty
		jr	nz, print2
		ld	e, 0

print2:
		ld	a, e
		cp	17h
		ret	nc
		ld	(prtln+1), a
		ld	de, 4
		ld	hl, (prtadr)

print3:
		add	hl, de
		dec	a
		jr	nz, print3
		dec	hl
		ld	(prtadr_2), hl
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

prtadr:		dw 0
prtadr_2:	dw 0

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

list:					; Debugger klavesa L - urcenie poctu zobrazovanych zakladnych stavovych	informacii
		call	vstup
		jr	nz, list1
		ld	e, 17h

list1:
		ld	a, 16h
		sub	e
		sub	e
		ld	(scrln+1), a
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;
;;	      ;;
;;  Debugger  ;;
;;	      ;;
;;;;;;;;;;;;;;;;

dbg:					; Prikaz mrs>dbg - spustenie debuggera
		call	getend
		dec	de
		ld	(memtop), de	; Koniec volnej	pamete a zaciatok zdrojoveho textu
		call	outbr		; Debugger klavesa O - deaktivacia breakpointu

oebrpc:					; Hodnota SP pri spusteni systemu MRS
		ld	sp, (stack)
		ld	hl, retgo	; Navratova adresa pre spustane	programy
		push	hl
		ld	(rsp+1), sp	; Hodnota registra SP v	debuggeri

retfnc:
		ld	a, 20h ; ' '
		jr	errtxt		; Pracovny priestor pre	stack

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

bm1:					; Naposledy zadany prikaz debuggera (kod klavesy)
		jr	zac

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

		or	a
		ld	hl, (rpc)	; Hodnota registra PC v	debuggeri
		ld	de, (adrbrk+1)	; Adresa zadaneho breakpointu (0 = ziadny nie je)
		sbc	hl, de
		ld	hl,  zac+1	; Naposledy zadany prikaz debuggera (kod klavesy)
		ld	a, (hl)
		jr	z, cross	; Pocet	prechodov cez breakpoint
		cp	47h ; 'G'
		jr	nz, zac		; Naposledy zadany prikaz debuggera (kod klavesy)
		set	5, (hl)
		jp	go		; Debugger klavesa G - spustenie programu

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

cross:					; Pocet	prechodov cez breakpoint
		ld	de, 0
		ld	a, d
		or	e
		jr	z, loop
		ld	a, (hl)
		cp	67h ; 'g'
		jr	nz, zac		; Naposledy zadany prikaz debuggera (kod klavesy)
		res	5, (hl)
		call	brktst		; Rychly test klavesy BREAK
		jp	c, sprac

loop:
		ld	a, 0C2h	; ''
		call	beep		; Vyraznejsi zvukovy signal so zachovanim AF
		jr	errtxt		; Pracovny priestor pre	stack

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

crosst:					; Pocitanie prechodov cez breakpoint
		push	hl
		ld	hl, (rpc)	; Hodnota registra PC v	debuggeri
		ld	de, (adrbrk+1)	; Adresa zadaneho breakpointu (0 = ziadny nie je)
		or	a
		sbc	hl, de
		pop	hl
		ret	nz
		ld	de, (cross+1)	; Pocet	prechodov cez breakpoint
		ld	a, d
		or	e
		ret	z
		dec	de
		ld	(cross+1), de	; Pocet	prechodov cez breakpoint
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

zac:					; Naposledy zadany prikaz debuggera (kod klavesy)
		ld	a, 0
		and	0DFh ; ''
		or	80h ; ''

errtxt:					; Pracovny priestor pre	stack
		ld	sp, begmod
		cp	0CEh ; ''
		jp	z, tstop
		push	af

wmm:
		jr	vr0

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

prtln:
		ld	a, 0
		or	a
		ld	l, a
		ld	de, (prtadr)
		call	nz, dumplr	; Vypis	L riadkov dumpu	pamete pre prikaz Dump
		ld	a, 18h
		ld	(wmm), a

; Vypis	stavov registrov

vr0:					; Zmazanie textoveho buffera
		call	clrd
		pop	af
		push	af
		and	7Fh ; ''
		ld	(hl), a
		inc	hl
		inc	hl
		ld	de, rpc		; Hodnota registra PC v	debuggeri
		call	dwhx		; Vypis	hexadecimalnej hodnoty z pameti
		ld	l, 1Bh
		ld	a, (raf+1)	; Hodnota registra AF v	debuggeri
		ld	de, tflg	; Priznaky pre ich vypis v debuggeri
		ld	b, 5
		rlca
		rrca

vr1:
		ld	(hl), 2Dh ; '-'
		jr	nc, vr2
		ex	de, hl
		ld	c, (hl)
		ex	de, hl
		ld	(hl), c

vr2:
		inc	de
		inc	hl
		rlca
		rlca
		djnz	vr1
		ld	a, (raf+2)	; Hodnota registra AF v	debuggeri
		call	bnhx		; Prevod 8bit hodnoty na hexadecimalne cislo
		inc	hl
		ld	b, 6
		ld	de,  rbc+1	; Hodnota registra BC v	debuggeri

vr3:					; Vypis	hexadecimalnej hodnoty z pameti
		call	dwhx
		inc	de
		inc	de
		inc	hl
		djnz	vr3
		pop	af
		cp	0D4h ; ''
		push	af
		rlca
		jr	nc, vr4

scrln:
		ld	a, 17h
		cp	17h
		jp	nc, vrtst
		call	rolup		; Posun	casti obrazovky	o dva riadky hore

vr4:					; Hodnota registra PC v	debuggeri
		ld	hl, (rpc)
		call	disrow		; Disasemblovanie jednej instrukcie na adrese HL
		call	outdlg		; Vypis	buffera	na spodny riadok obrazovky
		ld	hl, 1607h
		ld	b, 13h

inv:					; Invertovanie znaku na	obrazovke
		call	invpix
		inc	l
		djnz	inv
		pop	af
		jr	z, tstop

ink:					; ; Obsluha klavesnice s autorepeatom
		call	inkey
		ld	(zac+1), a	; Naposledy zadany prikaz debuggera (kod klavesy)
		cp	4Ah ; 'J'
		jp	z, sprac
		and	0DFh ; ''
		ld	hl, tabfn	; Ovladacie klavesy debuggera
		ld	bc, 3
		cpir
		jp	z, usprac	; Debugger klavesy S,C,T,N - kontrolovany beh programu
		ld	c, 0Dh
		cpir
		ld	de, retfnc
		push	de
		add	hl, bc
		add	hl, bc
		add	hl, bc
		ld	e, (hl)
		inc	hl
		ld	d, (hl)
		jp	nz, beep	; Vyraznejsi zvukovy signal so zachovanim AF
		call	clrd		; Zmazanie textoveho buffera
		ld	(hl), a
		inc	hl
		push	de
		ld	a, c
		cp	5
		ret	nc

outdlg:					; Vypis	buffera	na spodny riadok obrazovky
		push	hl
		push	de
		call	outbdb		; Vypis	buffera	na spodny riadok obrazovky
		pop	de
		pop	hl
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

rolup:					; Posun	casti obrazovky	o dva riadky hore
		push	af
		call	rolup1		; Posun	casti obrazovky	o jeden	riadok hore
		pop	af

rolup1:					; Posun	casti obrazovky	o jeden	riadok hore
		push	bc
		push	de
		push	hl
		ld	h, a
		ld	a, 17h
		call	idel		; Posun	(casti)	obrazovky smerom hore
		pop	hl
		pop	de
		pop	bc
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

tabfn:		db 'SCTMDILXAPQNWROG' ; Ovladacie klavesy debuggera

		dw go			; Debugger klavesa G - spustenie programu
		dw outbr		; Debugger klavesa O - deaktivacia breakpointu
		dw regist		; Debugger klavesa R - nastavenie registrov
		dw wmpc			; Debugger klavesa W - nastavenie PC a memory okien
		dw usprac		; Debugger klavesy S,C,T,N - kontrolovany beh programu
		dw quit			; Debugger klavesa Q - ukoncenie debuggera
		dw print		; Debugger klavesa P - zobrazenie zadanej oblasti pamete pri zapise do nej
		dw anti			; Debugger klavesa A - disasembler - vypise strojovy kod od danej adresy
		dw exxx			; Debugger klavesa X - vymena registrov	za alternativne	(urobi EX AF,AF	a EXX)
		dw list			; Debugger klavesa L - urcenie poctu zobrazovanych zakladnych stavovych	informacii
		dw inbrk		; Debugger klavesa I - vytvorenie breakpointu
		dw dump			; Debugger klavesa D - vypis pameti a hladanie bajtov/textov v pameti
		dw modify		; Debugger klavesa M - modifikacia obsahu pameti

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

vrtst:
		pop	af
		push	af
		jp	nz, vr4
		call	outdlg		; Vypis	buffera	na spodny riadok obrazovky

tstop:					; Rychly test klavesy BREAK
		call	brktst
		jp	nc, retfnc

usprac:					; Debugger klavesy S,C,T,N - kontrolovany beh programu
		ld	de, ii

uspr1:					; Hodnota registra PC v	debuggeri
		ld	hl, (rpc)
		ld	a, (de)
		or	a
		jr	z, sprac
		cp	0EDh ; ''
		jr	nz, uspr2
		inc	de
		cp	(hl)
		jr	nz, uspr3
		ld	a, (de)
		inc	hl

uspr2:
		cp	(hl)

uspr3:
		inc	de
		jr	nz, uspr1
		call	hard		; Kontrola zadaneho prikazu v debuggeri
		ld	a, 49h ; 'I'
		call	nc, beep	; Vyraznejsi zvukovy signal so zachovanim AF
		jp	nc, errtxt	; Pracovny priestor pre	stack

sprac:					; Hodnota registra PC v	debuggeri
		ld	hl, (rpc)
		ld	c, (hl)
		ld	a, c
		ex	de, hl
		inc	de
		ld	hl, byte
		push	hl

ed:
		ld	b, 2
		cp	0EDh ; ''
		jr	nz, fdd
		ld	a, (de)
		and	0E4h ; ''
		cp	0A0h ; ''
		ld	a, (de)
		jr	nz, ed1b
; Rekurzie
		call	hard		; Kontrola zadaneho prikazu v debuggeri
		ret	c
		ld	a, (de)
		rra
		ret	c
		ld	de, (rbc+1)	; Hodnota registra BC v	debuggeri
		ld	hl, (rde+1)	; Hodnota registra DE v	debuggeri
		rra
		jr	nc, rek1
		ld	hl, (rhl+1)	; Hodnota registra HL v	debuggeri
		ld	e, d
		ld	d, 0
		inc	e
		dec	e
		jr	nz, rek1
		inc	d

rek1:
		ld	bc, 1
		rra
		rra
		jr	nc, rek2
		dec	bc
		dec	bc

rek2:
		rra
		ld	a, b
		ld	b, 2
		jp	nc, wmem	; Zistenie ci adresa na	ktoru sa ma zapisovat nie je v niektorom pametovom okne
		ld	b, a

rek3:					; Zistenie ci adresa na	ktoru sa ma zapisovat nie je v niektorom pametovom okne
		call	wmem
		add	hl, bc
		dec	de
		ld	a, d
		or	e
		jr	nz, rek3
		ld	b, 2
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

ed1b:
		or	a

ed1b_1:
		jp	m, undef
		sub	40h ; '@'
		jr	c, ed1b_1
		ld	hl, tabed
		scf
		jr	long

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

fdd:
		ld	a, c
		and	0DFh ; ''
		cp	0DDh ; ''
		jr	nz, cb
		ld	a, (de)
		cp	0CBh ; ''
		jr	nz, fdd1
		inc	de
		inc	de
		ld	a, (de)
		and	7
		cp	6
		jp	nz, undef
		ld	b, 4
		jr	fdcb

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

fdd1:
		cp	45h ; 'E'
		ret	z
		cp	4Dh ; 'M'
		ret	z
		cp	67h ; 'g'
		ret	z
		cp	6Fh ; 'o'
		ret	z
		cp	63h ; 'c'
		ret	z
		inc	b
		call	prg1
		ld	hl, tabfd0
		ld	a, (de)
		scf
		jr	long

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

cb:
		ld	a, c
		cp	0CBh ; ''
		jr	nz, base

fdcb:
		ld	a, (de)
		rla
		jr	c, testcb
		rla
		ret	c

testcb:
		ld	a, (de)
		and	7
		cp	6
		ret	nz

memhl:					; Nacitanie displacementu z instrukcie a vypocet vyslednej adresy
		call	hlortd
		jp	wmem		; Zistenie ci adresa na	ktoru sa ma zapisovat nie je v niektorom pametovom okne

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

base:
		dec	b
		call	prg1
		ld	a, c
		and	0C0h ; ''
		ret	po
		ld	a, c
		and	7Fh ; ''
		ld	hl, tabase
		dec	de

long:
		push	af
		ld	c, a
		and	3
		ld	b, a
		xor	c
		rrca
		rrca
		add	a, l
		ld	l, a
		adc	a, h
		sub	l
		ld	h, a
		ld	a, (hl)
		rlca
		rlca
		inc	b

lon1:
		rrca
		rrca
		djnz	lon1
		and	3
		jp	z, undef
		ld	b, a
		pop	af
		jr	nc, lon2
		inc	b

lon2:					; Kontrola zadaneho prikazu v debuggeri
		call	hard
		ret	z
		ld	a, (de)
		ld	hl, (rbc+1)	; Hodnota registra BC v	debuggeri
		cp	2
		jr	z, lonw
		ld	hl, (rde+1)	; Hodnota registra DE v	debuggeri
		cp	12h
		jr	z, lonw
		ld	hl, tabdde

lon3:
		ld	a, (de)
		and	(hl)
		inc	hl
		cp	(hl)
		inc	hl
		ld	c, (hl)
		jr	z, lon5
		inc	hl
		ld	a, (hl)
		or	a
		jr	nz, lon3
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

lon5:					; Nacitanie displacementu z instrukcie a vypocet vyslednej adresy
		call	hlortd
		bit	0, c
		jr	nz, lonw
		ld	a, (de)
		or	a
		jp	m, lon6
		and	1Fh

lon6:
		bit	3, c
		jr	z, noflags
		rrca
		rrca
		rrca
		and	7
		rra
		push	hl
		push	af
		add	a, 8		; low tbflag
		ld	l, a
		adc	a, 0EFh	; ''   ; high tbflag
		sub	l
		ld	h, a
		ld	a, (raf+1)	; Hodnota registra AF v	debuggeri
		and	(hl)
		rlca
		rlca

flags1:
		ld	h, a
		pop	af
		ld	a, h
		pop	hl
		adc	a, a
		or	a
		jp	po, skok

noflags:
		ld	a, (de)
		bit	1, c
		jr	z, lon7
		inc	de
		ex	de, hl
		ld	e, (hl)
		inc	hl
		ld	d, (hl)
		ex	de, hl
		cp	32h ; '2'
		inc	hl
		call	nz, wmem	; Zistenie ci adresa na	ktoru sa ma zapisovat nie je v niektorom pametovom okne
		dec	hl

lonw:					; Zistenie ci adresa na	ktoru sa ma zapisovat nie je v niektorom pametovom okne
		jp	wmem

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

lon7:
		bit	2, c
		jr	z, lon9
		ld	hl, (rsp+1)	; Hodnota registra SP v	debuggeri
		cp	0E3h ; ''
		jr	z, lon8
		dec	hl
		dec	hl

lon8:					; Zistenie ci adresa na	ktoru sa ma zapisovat nie je v niektorom pametovom okne
		call	wmem
		inc	hl
		call	wmem		; Zistenie ci adresa na	ktoru sa ma zapisovat nie je v niektorom pametovom okne

lon9:
		ld	a, c
		and	0F8h ; ''
		ret	z
		ld	hl, jump
		ex	(sp), hl
		ld	a, (de)
		cp	0E9h ; ''
		jr	z, ihtohl	; Zistenie ci instrukcia ma prefix #DD / #FD
		and	38h ; '8'
		ld	l, a
		ld	a, (de)
		or	38h ; '8'
		inc	a
		ld	h, a
		inc	de
		jr	z, lon16
		bit	7, c
		jr	z, lon14
		ld	a, (de)
		ld	l, a
		rlca
		sbc	a, a
		ld	h, a
		add	hl, de
		dec	de
		ld	a, (de)
		cp	10h		; djnz
		jr	nz, lon12
		ld	a, (rbc+2)	; Hodnota registra BC v	debuggeri
		dec	a
		jr	nz, lon11
		ld	l, e
		ld	h, d
		inc	hl

lon11:
		scf

lon12:
		inc	hl
		push	af
		call	wpc		; Zistenie ci adresa vykonavaneho programu je v	niektorom pametovom okne
		pop	af
		ret	nc
		ld	(rbc+2), a	; Hodnota registra BC v	debuggeri
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

lon14:					; Hodnota registra SP v	debuggeri
		ld	hl, (rsp+1)
		bit	5, c
		jr	nz, lon15
		bit	4, c
		ex	de, hl

lon15:
		ld	e, (hl)
		inc	hl
		ld	d, (hl)
		inc	hl
		ex	de, hl
		ret	z
		call	wpc		; Zistenie ci adresa vykonavaneho programu je v	niektorom pametovom okne
		bit	5, c
		jr	nz, lon17

lon16:
		push	hl
		ld	hl, (rsp+1)	; Hodnota registra SP v	debuggeri
		dec	hl
		ld	(hl), d
		dec	hl
		ld	(hl), e
		ex	de, hl
		pop	hl

lon17:					; Hodnota registra SP v	debuggeri
		ld	(rsp+1), de
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

hlortd:					; Nacitanie displacementu z instrukcie a vypocet vyslednej adresy
		call	ihtohl
		ret	nz
		push	de
		ld	de, (rpc)	; Hodnota registra PC v	debuggeri
		inc	de
		inc	de
		ld	a, (de)
		ld	e, a
		rla
		sbc	a, a
		ld	d, a
		add	hl, de
		pop	de
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

ihtohl:					; Zistenie ci instrukcia ma prefix #DD / #FD
		ld	hl, (rpc)
		ld	a, (hl)
		ld	hl, (rix+2)	; Hodnota registra IX v	debuggeri
		cp	0DDh ; ''
		ret	z
		ld	hl, (riy+2)	; Hodnota registra IY v	debuggeri
		cp	0FDh ; ''
		ret	z
		ld	hl, (rhl+1)	; Hodnota registra HL v	debuggeri
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

prg1:
		cp	76h ; 'v'
		jp	z, undef
		and	0F8h ; ''
		cp	70h ; 'p'
		ret	nz
		pop	af
		jp	memhl

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

tabase:		db  5Dh	; ]
		db  65h	; e
		db  55h	; U
		db  65h	; e
		db  5Eh	; ^
		db  65h	; e
		db  56h	; V
		db  65h	; e
		db  7Eh	; ~
		db  65h	; e
		db  76h	; v
		db  65h	; e
		db  7Eh	; ~
		db  65h	; e
		db  76h	; v
		db  65h	; e
		db 0F5h	; 
		db  67h	; g
		db  35h	; 5
		db  6Fh	; o
		db 0B5h	; 
		db  67h	; g
		db 0B5h	; 
		db  63h	; c
		db  75h	; u
		db  67h	; g
		db  75h	; u
		db  63h	; c
		db  75h	; u
		db  67h	; g
		db  75h	; u
		db  63h	; c
tabed:		db 0D5h	; 
		db  55h	; U
		db 0D5h	; 
		db  45h	; E
		db 0D5h	; 
		db  50h	; P
		db 0D5h	; 
		db  50h	; P
		db 0D5h	; 
		db  40h	; @
		db 0D5h	; 
		db  40h	; @
		db 0D5h	; 
		db    0
		db 0D5h	; 
		db    0
tabfd0:		db    0
		db    0
		db    4
		db    0
		db    0
		db    0
		db    4
		db    0
		db  7Ch	; |
		db  25h	; %
		db  74h	; t
		db  25h	; %
		db    0
		db  3Ah	; :
		db    4
		db    0
		db    0
		db  21h	; !
		db    0
		db  21h	; !
		db    0
		db  25h	; %
		db    0
		db  25h	; %
		db  15h
		db  25h	; %
		db  55h	; U
		db  25h	; %
		db    0
		db    0
		db    0
		db  25h	; %
		db    0
		db  25h	; %
		db    0
		db  25h	; %
		db    0
		db  25h	; %
		db    0
		db  25h	; %
		db    0
		db  25h	; %
		db    0
		db  25h	; %
		db    0
		db  25h	; %
		db    0
		db  25h	; %
		db    0
		db    0
		db    0
		db    0
		db    0
		db    0
		db    0
		db    0
		db  44h	; D
		db    4
		db    4
		db    0
		db    0
		db    0
		db    4
		db    0
tabdde:		db 0E7h	; 
		db  20h
		db  88h	; 
		db 0F7h	; 
		db  10h
		db  80h	; 
		db 0FFh
		db 0C9h	; 
		db  20h
		db 0F7h	; 
		db  45h	; E
		db  20h
		db 0C7h	; 
		db 0C0h	; 
		db  28h	; (
		db 0FFh
		db 0C3h	; 
		db  40h	; @
		db 0FFh
		db 0E9h	; 
		db  40h	; @
		db 0C7h	; 
		db 0C2h	; 
		db  48h	; H
		db 0FFh
		db 0CDh	; 
		db  54h	; T
		db 0C7h	; 
		db 0C4h	; 
		db  5Ch	; \
		db 0C7h	; 
		db 0C7h	; 
		db  54h	; T
; Modifikacie
		db 0EFh	; 
		db  22h	; "
		db    2
		db 0FEh	; 
		db  34h	; 4
		db    1
		db 0FFh
		db  36h	; 6
		db    1
		db 0CFh	; 
		db  43h	; C
		db    2
		db 0F7h	; 
		db  67h	; g
		db    1
		db 0CFh	; 
		db 0C5h	; 
		db    4
		db 0FFh
		db 0E3h	; 
		db    4
		db 0FFh
		db  70h	; p
		db    1
		db    0

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

undef:					; Kontrola zadaneho prikazu v debuggeri
		call	hard
		ld	a, 49h ; 'I'
		jp	nc, errtxt	; Pracovny priestor pre	stack
		ld	b, 1

skok:					; Hodnota registra PC v	debuggeri
		ld	hl, (rpc)

skok_3:
		inc	hl
		djnz	skok_3
		ld	c, b

jump:					; Zistenie ci adresa vykonavaneho programu je v	niektorom pametovom okne
		call	wpc
		call	crosst		; Pocitanie prechodov cez breakpoint
		ld	(rpc), hl	; Hodnota registra PC v	debuggeri
		ld	a, (zac+1)	; Naposledy zadany prikaz debuggera (kod klavesy)
		and	0DFh ; ''
		cp	43h ; 'C'
		jr	nz, jum1
		bit	4, c
		jr	nz, callgo	; Obsluha vykonania instrukcie na adrese HL

jum1:
		jp	bm1

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

inbrk:					; Debugger klavesa I - vytvorenie breakpointu
		ld	hl,  adrbrk+1
		call	reg02		; Zadanie jednej hodnoty a jej ulozenie	na (HL)

inb1:					; Zmazanie textoveho buffera
		call	clrd
		ld	(hl), 6Eh ; 'n'
		call	vstup		; Zadanie jednej hodnoty
		jr	nz, imb2
		ld	de, 0

imb2:					; Pocet	prechodov cez breakpoint
		ld	(cross+1), de
		ld	a, 2Eh ; '.'

inout:
		ld	(bm1), a
		ld	(bm2), a
		ld	(bm3), a
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

outbr:					; Debugger klavesa O - deaktivacia breakpointu
		ld	a, 18h
		jr	inout

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

retp:		dw retbr		; Vektor pre RST #10 sluziace ako breakpoint

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

go:					; Debugger klavesa G - spustenie programu
		ld	hl, (rpc)
		xor	a

callgo:					; Obsluha vykonania instrukcie na adrese HL
		ld	(instr_1), hl
		ld	a, 0C3h	; ''   ; #C3 = Instrukcia JP
		ld	(instr_dbg), a	; Vykonavana instrukcia	v rezimoch S,T,N
		ld	hl, retp	; Vektor pre RST #10 sluziace ako breakpoint
		ld	(rst10_vektor),	hl
		jr	z, bm2
		ld	sp, (rsp+1)	; Hodnota registra SP v	debuggeri
		pop	hl
		push	hl
		ld	(adrcal+1), hl	; Adresa za instrukciou	krokovanou v rezime C (ostre vykonane vsetkych CALLov)
		ld	a, (hl)
		ld	(bytcal+1), a	; Povodny bajt za instrukciou krokovanou v rezime C (ostre vykonane vsetkych CALLov)
		ld	(hl), 0D7h ; '' ; #D7 = Instrukcia RST #10 sluziaca ako breakpoint
		ld	a, 2Eh ; '.'    ;  #2E = Instrukcia LD L,n
		ld	(cm1), a

bm2:
		jr	goon

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

		ld	hl, (adrbrk+1)	; Adresa zadaneho breakpointu (0 = ziadny nie je)
		ld	a, (hl)
		ld	(bytbrk+1), a	; Povodny bajt na adrese kde je	teraz breakpoint
		ld	(hl), 0D7h ; '' ; #D7 = Instrukcia RST #10 sluziaca ako breakpoint

goon:
		jr	refres

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

retbr:					; Sem to skoci ak sa narazi na breakpoint
		inc	sp
		inc	sp
		pop	hl
		exx
		ex	(sp), hl
		dec	hl
		ld	(rpc), hl	; Hodnota registra PC v	debuggeri

bm3:
		jr	cm1

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

adrbrk:					; Adresa zadaneho breakpointu (0 = ziadny nie je)
		ld	hl, 0

bytbrk:					; Povodny bajt na adrese kde je	teraz breakpoint
		ld	(hl), 0

cm1:
		jr	retb

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

adrcal:					; Adresa za instrukciou	krokovanou v rezime C (ostre vykonane vsetkych CALLov)
		ld	hl, 0

bytcal:					; Povodny bajt za instrukciou krokovanou v rezime C (ostre vykonane vsetkych CALLov)
		ld	(hl), 0
		ld	hl, cm1
		ld	(hl), 18h	; #18 =	Instrukcia JR ...

retb:
		pop	hl
		jr	instr_4

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

retgo:					; Navratova adresa pre spustane	programy
		nop
		ld	sp, (stack)	; Hodnota SP pri spusteni systemu MRS
		push	hl
		ld	hl, 453Eh	; Instrukcia LD	A,'E'
		ld	(zac), hl	; Naposledy zadany prikaz debuggera (kod klavesy)
		ld	hl, retgo	; Navratova adresa pre spustane	programy
		ex	(sp), hl
		push	hl
		jr	bm3

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

byte:					; Hodnota registra PC v	debuggeri
		ld	hl, (rpc)
		ld	de, retgo	; Navratova adresa pre spustane	programy
		xor	a
		ld	c, b
		ld	b, a
		sbc	hl, de
		add	hl, de
		ld	a, 45h ; 'E'
		jp	z, errtxt	; Pracovny priestor pre	stack
		push	hl
		add	hl, bc
		call	wpc		; Zistenie ci adresa vykonavaneho programu je v	niektorom pametovom okne
		call	hard		; Kontrola zadaneho prikazu v debuggeri
		jr	z, byte1
		pop	hl
		ld	de, instr_dbg	; Vykonavana instrukcia	v rezimoch S,T,N
		ldir
		call	crosst		; Pocitanie prechodov cez breakpoint

byte1:					; Hodnota registra PC v	debuggeri
		ld	(rpc), hl

refres:					; Hodnota registra AF v	debuggeri
		ld	hl, (raf+1)
		push	hl
		pop	af

raf:					; Hodnota registra AF v	debuggeri
		ld	bc, 0AAFFh
		nop

rbc:					; Hodnota registra BC v	debuggeri
		ld	bc, 0BBCCh
		nop

rde:					; Hodnota registra DE v	debuggeri
		ld	de, 0DDEEh
		nop

rhl:					; Hodnota registra HL v	debuggeri
		ld	hl, 2211h

rix:					; Hodnota registra IX v	debuggeri
		ld	ix, 0DDDDh

riy:					; Hodnota registra IY v	debuggeri
		ld	iy, 5C3Ah
		nop

rsp:					; Hodnota registra SP v	debuggeri
		ld	sp, 0

instr_dbg:				; Vykonavana instrukcia	v rezimoch S,T,N
		nop

instr_1:
		nop

instr_:
		nop
		nop

instr_4:				; Hodnota registra HL v	debuggeri
		ld	(rhl+1), hl
		ld	(rsp+1), sp	; Hodnota registra SP v	debuggeri
		ld	sp, begmod	; Pracovny priestor pre	stack
		push	af
		pop	hl
		ld	(raf+1), hl	; Hodnota registra AF v	debuggeri
		ld	(rbc+1), bc	; Hodnota registra BC v	debuggeri
		ld	(rde+1), de	; Hodnota registra DE v	debuggeri
		ld	(rix+2), ix	; Hodnota registra IX v	debuggeri
		ld	(riy+2), iy	; Hodnota registra IY v	debuggeri
		ld	hl, 0
		ld	(instr_dbg), hl	; Vykonavana instrukcia	v rezimoch S,T,N
		ld	(instr_), hl
		jp	bm1

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

exxx:					; Debugger klavesa X - vymena registrov	za alternativne	(urobi EX AF,AF	a EXX)
		ld	hl, 0D908h
		ld	(instr_dbg), hl	; #D9 =	exx , #08 = ex af,af
		jr	refres

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

rpc:		dw 0			; Hodnota registra PC v	debuggeri
wm:		dw 0			; Hranice pre pametove okna
wm2:		dw  0, 0, 0, 0,	0, 0, 0
countr:		dw  0,-1, 0, 0,	0, 0, 0, 0 ; Hranice pre PC okna
		dw  0, 0, 0, 0,	0, 0, 0, 0
		dw  0, 0, 0, 0,	0, 0, 0, 0
		dw 0
		dw 0
		dw 0
		dw 0
		dw 0
		dw 0
		dw 0			; Pracovny priestor pre	stack
		dw 0
begmod:		dw 0			; Adresa kde bude prelozeny kod	ak nie je inak specifikovane ORG-om
endmod:		dw 0			; Hranica v pameti po ktoru je mozne ukladat prelozeny kod
pcode:		dw 0			; Adresa zadana	ORG-om alebo direktivou	*c kam sa bude ukladat kod
aldind_:	db 0			; Priznak kompilacneho prikazu:	0 = asm, 2 = ald
eind:		db 0
linn:		dw 0
curpc:		dw 0			; Adresa zadana	ORG-om kde bude	kompilovany kod	fungovat
nextpc:		dw 0			; Adresa ako curpc ale nasledujucej instrukcie
plist:		dw 0
iunpln:		db 0
exaf:		db 0
prefix:		db 0DDh	; 
		db 0FDh	; 
		db 0CBh	; 
		db 0EDh	; 
tude:		db  0Dh
		db 'undefined externals:'
tude2:		db  0Dh
tnoend:		db 'no end  '
terr:		db  0Dh
terrors:	db 'errors: '
errcnt:		dw 0			; Pocet	chyb pri preklade
		dw 0
		db  20h
tlib:		db 'lib>'
clib:		db 'sav'
		dw savlib		; Prikaz lib>sav - Ulozenie kniznice na	pasku
		db 'loa'
		dw loalib		; Prikaz lib>loa - Nacitanie kniznice s	pasky
		db 'del'
		dw delmod		; Prikaz lib>del - Zmazanie posledneho modulu kniznice
		db 'lst'
		dw lstlib		; Prikaz lib>lst - Vypis modulov kniznice
		db 'ent'
		dw entry		; Prikaz lib>ent - Oznacenie vstupneho bodu pre	spustenie programu v kniznici
		db 0FFh

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;   schent - vyhlada vstupny bod v kniznici.  da sa vyuzit  ak	napr.	jeden
;	     program  produkuje	 data, ktore ma	spracovat iny modul kniznice.
;	     pomocou schent moze dany program najst tabulku  v	inom  module,
;	     kam ma ulozit vystupne data.
;	     vstup:  <hl> = adresa retazca, ktory  udava  pozadovane  vstupne
;	     navestie.	retazec	musi koncit binarnou nulou.
;	     vystup:<z flag> = 1 - chybna syntax alebo v kniznici nie je take
;	     meno.  inac
;		     <hl> = adresa mena	v kniznici.  na	 tejto	adrese	je  6
;	     znakov  meno a dalsie dva znaky adresa, ktoru toto	meno oznacuje
;	     (napr.  adresa tabulky, ktorej meno je popisane ako ent).
;	     meni sa:  <af>, <bc>, <de>, <hl>

schent:					; Vyhladanie vstupneho bodu v kniznici
		push	hl
		ld	de, libbeg	; Zaciatok kniznice a napis "sysmod"
		call	gent1		; Vyhladanie tabulky navesti ENT v moduloch kniznice

se1:
		ex	de, hl
		ex	(sp), hl
		push	hl
		push	de
		push	bc
		call	cmpsym		; Porovnanie dvoch navesti ci sa jedna o to iste navestie
		pop	bc
		pop	hl
		pop	de
		pop	de
		jr	z, se2
		push	de
		dec	sp
		dec	sp
		pop	hl
		pop	de
		push	hl
		call	gentnm
		jr	nz, se1
		pop	hl
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

se2:
		inc	a
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

cmpsym:					; Porovnanie dvoch navesti ci sa jedna o to iste navestie
		push	bc
		push	de
		push	hl
		ld	b, 6
		ex	de, hl

cs1:
		ld	a, (de)
		cp	20h ; ' '
		jr	nc, cs2
		ld	a, 20h ; ' '
		dec	de

cs2:
		res	7, a
		bit	7, (hl)
		jr	z, cs3
		set	7, a

cs3:
		cp	(hl)
		inc	de
		inc	hl
		jr	nz, cs4
		dec	b
		jr	nz, cs1

cs4:
		pop	hl
		pop	de
		pop	bc
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

stbyt0:					; Nacitanie jedneho bajtu z (HL) a ulozenie do kodu pri	kompilacii
		ld	a, (hl)

stbyte:					; Ulozenie jedneho bajtu do kodu pri kompilacii
		push	hl
		push	de
		push	af
		ld	de, (endmod)	; Hranica v pameti po ktoru je mozne ukladat prelozeny kod
		ld	hl, (pcode)	; Adresa zadana	ORG-om alebo direktivou	*c kam sa bude ukladat kod
		ld	a, l
		sub	e
		ld	a, h
		sbc	a, d
		jp	nc, wtmf	; Chybove hlasenie "MEM FULL"
		pop	af
		ld	d, a
		ld	a, l
		or	h
		ld	a, d
		jr	z, nostb
		ld	(hl), d
		inc	hl
		ld	(pcode), hl	; Adresa zadana	ORG-om alebo direktivou	*c kam sa bude ukladat kod

nostb:
		pop	de
		pop	hl
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

movsym:					; Ulozenie nazvu navestia do skompilovaneho kodu (potrebne kvoli kniznici)
		ld	b, 6

ms1:
		ld	a, (hl)
		and	7Fh ; ''
		jr	nz, ms2
		ld	a, 20h ; ' '
		dec	hl

ms2:					; Ulozenie jedneho bajtu do kodu pri kompilacii
		call	stbyte
		inc	hl
		djnz	ms1
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

gmodnm:					; Zisti	hodnotu	navestia a porovna so zaciatkom	volnej pamete
		ld	hl, 6
		add	hl, de
		ld	e, (hl)
		inc	hl
		ld	d, (hl)
		ld	hl, (memory)	; Koniec kniznice a zaciatok volnej pamete
		jp	cmhlde		; Porovnanie HL	a DE

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

getn0:					; Zisti	hodnotu	navestia a porovna so zaciatkom	volnej pamete
		call	gmodnm
		ret	z

gent1:					; Vyhladanie tabulky navesti ENT v moduloch kniznice
		call	gaexen
		jr	z, getn0
		ld	c, a

gentnm:
		dec	c
		jp	m, getn0

gent2:					; Zisti	adresu nasledujuceho modulu kniznice
		call	gaexen
		push	bc
		push	hl
		ld	l, c
		inc	c
		ld	h, 0
		add	hl, hl
		add	hl, hl
		add	hl, hl
		pop	bc
		add	hl, bc
		pop	bc
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

gaexen:					; Zisti	pocet navesti v	danom module kniznice (DE = adresa modulu)
		ld	hl, 8
		add	hl, de
		ld	a, (hl)
		inc	hl
		ld	h, (hl)
		ld	l, a
		or	h
		ld	a, (hl)
		inc	hl
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

gext0:					; Zisti	hodnotu	navestia a porovna so zaciatkom	volnej pamete
		call	gmodnm
		ret	z

gext1:					; Vyhladanie tabulky navesti EXT v moduloch kniznice
		call	gaexen
		jr	z, gext0
		ld	c, a
		call	gent2		; Zisti	adresu nasledujuceho modulu kniznice

getx2:
		ld	a, (hl)
		or	a
		jr	z, gext0
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

gextnm:
		ld	bc, 6
		add	hl, bc
		ld	c, (hl)
		inc	hl
		add	hl, bc
		add	hl, bc
		jr	getx2

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

vstoax:					; Adresa labelu	 (In: C=cislo labelu  Out: HL=adresa labelu)
		ex	de, hl
		call	vstoas		; Adresa labelu	 (In: C=cislo labelu  Out: DE=adresa labelu)
		ex	de, hl
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

putsvl:					; Zadefinuje label na zadanu hodnotu (s	osetrenim duplicitnych definicii)
		push	de
		push	af
		ex	de, hl
		call	vstoax		; Adresa labelu	 (In: C=cislo labelu  Out: HL=adresa labelu)
		ld	a, (hl)
		rlca
		scf
		rra
		ld	(hl), a
		sbc	a, a
		and	80h ; ''
		inc	hl
		or	(hl)
		ld	(hl), a
		inc	hl
		pop	af
		ld	a, (hl)
		rla
		jr	c, psvlq
		inc	hl
		jr	nz, pv1_b
		set	7, (hl)
		ld	d, h
		ld	e, l
		inc	de
		inc	de
		inc	de

pv1_b:
		inc	hl
		inc	hl
		inc	hl
		ld	(hl), e
		inc	hl
		ld	(hl), d

psvlq:
		ex	de, hl
		pop	de
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

ald:					; Prikaz mrs>ald - Preklad a linkovanie	zdrojoveho textu a potom skok do debuggera
		ld	a, 2

asm:					; Prikaz mrs>asm - preklad zdrojoveho textu
		ld	(aldind_), a
		ld	hl, (libtop)	; Koniec kniznice a zaciatok volnej pamete
		ld	(pcode), hl	; Adresa zadana	ORG-om alebo direktivou	*c kam sa bude ukladat kod
		ld	(memory), hl	; Koniec kniznice a zaciatok volnej pamete
		push	de
		call	getend		; Zistenie kde v pameti	zacina zdrojovy	text
		ld	(endmod), de	; Hranica v pameti po ktoru je mozne ukladat prelozeny kod
		pop	hl
		ld	a, (hl)
		or	a
		jr	z, noname
		cp	20h ; ' '
		jp	nz, mrs2	; Oprava textu zadaneho	v module "mrs"
		inc	hl
		call	getlbl		; Vyhladanie navestia v	tabulke	navesti
		jp	c, mrs2		; Oprava textu zadaneho	v module "mrs"
		ld	de, libbeg	; Zaciatok kniznice a napis "sysmod"

as1:					; Porovnanie dvoch navesti ci sa jedna o to iste navestie
		call	cmpsym
		jr	z, name
		push	hl
		call	gmodnm		; Zisti	hodnotu	navestia a porovna so zaciatkom	volnej pamete
		pop	hl
		jr	nz, as1
		ld	hl, buffer_meno

noname:					; Ulozenie nazvu navestia do skompilovaneho kodu (potrebne kvoli kniznici)
		call	movsym
		ld	b, 4
		xor	a

as2:					; Ulozenie jedneho bajtu do kodu pri kompilacii
		call	stbyte
		djnz	as2
		jr	sasm

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

name:
		ld	hl, 6
		add	hl, de
		ld	e, (hl)
		inc	hl
		ld	d, (hl)
		xor	a
		inc	hl
		ld	(hl), a
		inc	hl
		ld	(hl), a
		inc	hl
		ld	(pcode), hl	; Adresa zadana	ORG-om alebo direktivou	*c kam sa bude ukladat kod
		ld	(endmod), de	; Hranica v pameti po ktoru je mozne ukladat prelozeny kod

sasm:					; Pocitadlo pre	pocet riadkov na jednu stranku listingu	(0 = bez stran)
		ld	(page),	a
		ld	(terrors+7), a
		ld	a, 30h ; '0'
		ld	(lind+1), a	; Skok pre vypis listingu: 0x04	= vsetko, 0x30 = iba chybne riadky
		ld	a, 0Dh
		ld	(scrlp+1), a	; Znak pre vypis listingu (0x0D	= obrazovka, 0x20 = tlaciaren)
		ld	hl, outchr	; Vypis	jedneho	znaku na obrazovku
		ld	(opsch3+1), hl	; Volanie rutinky pre vypis jedneho znaku listingu (outchr = obrazovka,	pntchr = tlaciaren)
		ld	hl, (adstab)	; Adresa tabulky navesti
		ld	a, (hl)
		or	a
		jr	z, sa3_lib
		ld	c, a

sa1_lib:				; Adresa labelu	 (In: C=cislo labelu  Out: HL=adresa labelu)
		call	vstoax
		ld	b, 6

sa2_lib:
		res	7, (hl)
		inc	hl
		djnz	sa2_lib
		dec	c
		jr	nz, sa1_lib

sa3_lib:				; Aktualny riadok zdrojoveho textu bude	prvy
		call	crtnin
		ld	hl, (pcode)	; Adresa zadana	ORG-om alebo direktivou	*c kam sa bude ukladat kod
		ld	(begmod), hl	; Adresa kde bude prelozeny kod	ak nie je inak specifikovane ORG-om

eachln:
		push	hl
		ld	hl, (curent)	; Adresa aktualneho riadku v zdrojovom texte
		ld	d, h
		ld	e, l
		call	skipln		; Presun na dalsi riadok v zdrojovom texte
		pop	hl
		jp	z, noend	; Chybove hlasenie "NO END"
		ld	a, (de)
		dec	de
		rlca
		jr	nc, nolbl
		ld	a, (de)
		dec	de
		ld	c, a
		ld	a, (de)
		cp	0Dh
		jr	nz, notequ
		push	hl
		push	bc
		dec	de
		call	getval		; Vyhodnotenie hodnoty vyrazu v	zdrojovom texte	 - v pripade chyby vrati nulu
		pop	bc
		or	a
		inc	a
		call	putsvl		; Zadefinuje label na zadanu hodnotu (s	osetrenim duplicitnych definicii)
		pop	hl
		jr	eachln

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

notequ:					; Zadefinuje label na zadanu hodnotu (s	osetrenim duplicitnych definicii)
		call	putsvl

nolbl:
		ld	a, (de)
		cp	0Fh
		jr	z, spass
		call	newpc		; Urcenie adresy nasledujucej instrukcie
		jr	eachln

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

spass:					; Aktualny riadok zdrojoveho textu bude	prvy
		call	crtnin
		call	illa		; Zmaze	obrazovku, nastavi kurzor vlavo	dole a vynuluje	pocet chyb
		ld	(linn),	hl
		ld	hl, (begmod)	; Adresa kde bude prelozeny kod	ak nie je inak specifikovane ORG-om
		ld	(pcode), hl	; Adresa zadana	ORG-om alebo direktivou	*c kam sa bude ukladat kod

asloop:					; Adresa zadana	ORG-om kde bude	kompilovany kod	fungovat
		ld	(curpc), hl
		call	asmain
		call	outcod		; Vytvorenie riadku pre	listing
		ld	hl, (curent)	; Adresa aktualneho riadku v zdrojovom texte
		call	skipln		; Presun na dalsi riadok v zdrojovom texte
		ld	hl, (nextpc)	; Adresa ako curpc ale nasledujucej instrukcie
		ld	a, (eind)
		or	a
		jr	nz, asloop
		inc	hl
		ld	(pcode), hl	; Adresa zadana	ORG-om alebo direktivou	*c kam sa bude ukladat kod
		ld	hl, (curent)	; Adresa aktualneho riadku v zdrojovom texte
		cp	(hl)
		jr	nz, nolabd
		ld	hl, (adstab)	; Adresa tabulky navesti
		cp	(hl)
		jr	z, nolabd
		ld	c, (hl)

sa4:					; Adresa labelu	 (In: C=cislo labelu  Out: HL=adresa labelu)
		call	vstoax
		ld	b, 6

sa5:
		bit	7, (hl)
		jr	nz, sa6
		inc	hl
		djnz	sa5
		call	vstoax		; Adresa labelu	 (In: C=cislo labelu  Out: HL=adresa labelu)
		ld	(hl), b

sa6:
		dec	c
		jr	nz, sa4

nolabd:
		xor	a
		ld	hl, errcnt	; Pocet	chyb pri preklade
		cp	(hl)
		jp	nz, erry
		ld	hl, (adstab)	; Adresa tabulky navesti
		cp	(hl)
		jr	z, sa20
		ld	c, (hl)
		push	bc

sa11:					; Adresa labelu	 (In: C=cislo labelu  Out: HL=adresa labelu)
		call	vstoax
		push	hl
		inc	hl
		inc	hl
		inc	hl
		inc	hl
		bit	7, (hl)
		pop	hl
		jr	z, sa12
		call	movsym		; Ulozenie nazvu navestia do skompilovaneho kodu (potrebne kvoli kniznici)
		call	stbyt0		; Nacitanie jedneho bajtu z (HL) a ulozenie do kodu pri	kompilacii
		inc	hl
		call	stbyt0		; Nacitanie jedneho bajtu z (HL) a ulozenie do kodu pri	kompilacii
		ld	hl, eind
		inc	(hl)

sa12:
		dec	c
		jr	nz, sa11
		pop	bc

sa13:					; Adresa labelu	 (In: C=cislo labelu  Out: HL=adresa labelu)
		call	vstoax
		push	hl
		inc	hl
		inc	hl
		inc	hl
		bit	7, (hl)
		pop	hl
		jr	z, sa17
		call	movsym		; Ulozenie nazvu navestia do skompilovaneho kodu (potrebne kvoli kniznici)
		push	bc
		xor	a
		call	stbyte		; Ulozenie jedneho bajtu do kodu pri kompilacii
		push	hl
		ld	hl, (pcode)	; Adresa zadana	ORG-om alebo direktivou	*c kam sa bude ukladat kod
		dec	hl
		ex	(sp), hl
		ld	b, h
		ld	c, l

sa14:
		ld	e, (hl)
		inc	hl
		ld	d, (hl)
		ld	a, b
		cp	d
		jr	nz, sa15
		ld	a, c
		cp	e
		jr	z, sa16

sa15:
		ld	a, e
		call	stbyte		; Ulozenie jedneho bajtu do kodu pri kompilacii
		ld	a, d
		call	stbyte		; Ulozenie jedneho bajtu do kodu pri kompilacii
		pop	hl
		inc	(hl)
		push	hl
		ex	de, hl
		jr	sa14

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

sa16:
		pop	hl
		pop	bc

sa17:
		dec	c
		jr	nz, sa13

sa20:					; Adresa ako curpc ale nasledujucej instrukcie
		ld	de, (nextpc)
		ld	hl, (pcode)	; Adresa zadana	ORG-om alebo direktivou	*c kam sa bude ukladat kod
		dec	hl
		call	cmhlde		; Porovnanie HL	a DE
		jr	nz, sa21
		ld	(pcode), hl	; Adresa zadana	ORG-om alebo direktivou	*c kam sa bude ukladat kod

sa21:					; Adresa kde bude prelozeny kod	ak nie je inak specifikovane ORG-om
		ld	hl, (begmod)
		dec	hl
		dec	hl
		ld	a, (eind)
		jr	z, sa18
		ld	(de), a
		xor	a
		call	stbyte		; Ulozenie jedneho bajtu do kodu pri kompilacii
		inc	hl
		ld	(hl), d
		dec	hl
		ld	(hl), e

sa18:
		dec	hl
		ld	a, (hl)
		dec	hl
		or	(hl)
		jr	nz, erry
		ex	de, hl
		ld	hl, (pcode)	; Adresa zadana	ORG-om alebo direktivou	*c kam sa bude ukladat kod
		ld	(memory), hl	; Koniec kniznice a zaciatok volnej pamete
		ex	de, hl
		ld	(hl), e
		inc	hl
		ld	(hl), d
		ld	hl, (libtop)	; Koniec kniznice a zaciatok volnej pamete
		ld	a, (hl)
		cp	20h ; ' '
		jr	z, erry
		ex	de, hl
		ld	(libtop), hl	; Koniec kniznice a zaciatok volnej pamete

erry:					; Vypis	CR-LF do listingu
		call	ocrlf
		call	symtab
		call	ocrlf		; Vypis	CR-LF do listingu

erryi:					; Pocet	chyb pri preklade
		ld	bc, (errcnt)
		ld	hl,  terrors+7
		call	bndc		; Prevod 16bit hodnoty na desiatkove cislo
		ld	b, l
		ld	hl, terr
		dec	b
		call	oc2_1		; Vypis	jedneho	riadku listingu
		call	ocrlf		; Vypis	CR-LF do listingu
		jr	err1

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

errout:
		ld	c, 1
		call	mrsd		; Dialogovy riadok bez vyhodnocovania prikazov

err1:
		ld	de, lnk1
		ld	bc, ilnli1
		ld	hl, aldind_	; Priznak kompilacneho prikazu:	0 = asm, 2 = ald
		xor	a
		cp	(hl)
		jp	z, monit	; Vstup	do modulu "mrs>"
		dec	(hl)
		jr	nz, nodbg
		call	getend		; Zistenie kde v pameti	zacina zdrojovy	text
		ld	(wm), de	; Hranice pre pametove okna
		ld	hl, endcod
		ld	(wm2), hl
		ld	de, dbg		; Prikaz mrs>dbg - spustenie debuggera

nodbg:
		ex	de, hl
		ld	a, (terrors+7)
		cp	30h ; '0'
		jp	nz, edi		; Prikaz mrs>edi - skok	do modulu edi>
		jp	(hl)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

noend:					; Chybove hlasenie "NO END"
		ld	hl, tnoend
		ld	b, 6
		jr	errout

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

asmain:
		ld	a, 1
		ld	(iunpln), a
		ld	hl, (curent)	; Adresa aktualneho riadku v zdrojovom texte
		push	hl
		ld	(nxtadr), hl	; Adresa dalsej	instrukcie
		call	unpln		; Nacita a depakuje riadok zdrojoveho textu do textoveho buffera
		pop	de
		ld	a, (de)
		dec	de
		rlca
		jr	nc, sp2
		ld	a, (de)
		dec	de
		ld	c, a
		call	vstoax		; Adresa labelu	 (In: C=cislo labelu  Out: HL=adresa labelu)
		inc	hl
		ld	a, (hl)
		rlca
		jr	nc, sp2
		ld	a, 4Dh ; 'M'

sp10:
		ld	(lst_chyba), a

sp2:
		ld	a, (de)
		sub	0Fh
		ld	(eind),	a
		push	de
		ld	hl, (curpc)	; Adresa zadana	ORG-om kde bude	kompilovany kod	fungovat
		push	hl
		call	newpc		; Urcenie adresy nasledujucej instrukcie
		ld	(nextpc), hl	; Adresa ako curpc ale nasledujucej instrukcie
		pop	de
		ld	hl, (plist)
		call	bnhx2		; Prevod 16bit hodnoty na hexadecimalne	cislo
		inc	hl
		ld	(plist), hl
		pop	de
		ld	a, (de)
		dec	de
		cp	0FEh ; ''
		ret	z
		rrca
		jp	c, asmpsi	; Kompilacia pseudoinstrukcii s	viac parametrami
		rlca
		ld	c, a

asmins:
		ld	hl, prefix
		ld	b, 4

savprx:
		rlc	c
		ld	a, (hl)
		call	c, savcod	; Spracovanie bajtu pri	kompilacii: Ulozenie do	pameti a vypis v listingu
		inc	hl
		djnz	savprx
		ld	a, (de)
		dec	de
		rlc	c
		ld	b, a
		jr	nc, notrel
		push	bc
		call	get8vl		; Ziskanie 8-bitovej hodnoty zo	zdrojoveho textu
		pop	bc
		bit	2, c
		jr	z, wocb
		ld	a, l
		ld	l, b
		ld	b, a

wocb:
		ld	a, b
		call	savcod		; Spracovanie bajtu pri	kompilacii: Ulozenie do	pameti a vypis v listingu
		ld	a, l

notrel:					; Spracovanie bajtu pri	kompilacii: Ulozenie do	pameti a vypis v listingu
		call	savcod
		sla	c
		ret	nc
		ld	a, b
		and	7
		jr	nz, asmadr
		ld	a, (de)
		and	3
		dec	a
		jr	z, reljmp
		ld	a, (de)
		and	60h ; '`'
		cp	20h ; ' '

reljmp:
		push	af
		call	getval		; Vyhodnotenie hodnoty vyrazu v	zdrojovom texte	 - v pripade chyby vrati nulu
		pop	af
		jr	nz, nospc
		ld	bc, (curpc)	; Adresa zadana	ORG-om kde bude	kompilovany kod	fungovat
		inc	bc
		scf
		sbc	hl, bc
		ld	a, l
		xor	h
		call	m, rngerr

nospc:					; Test osemnbitovej hodnoty na rozsah -256..+255
		call	test8
		ld	a, l
		jr	savcod		; Spracovanie bajtu pri	kompilacii: Ulozenie do	pameti a vypis v listingu

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

asmadr:
		or	c

asmexp:
		push	af
		call	getval		; Vyhodnotenie hodnoty vyrazu v	zdrojovom texte	 - v pripade chyby vrati nulu
		ld	a, l
		call	savcod		; Spracovanie bajtu pri	kompilacii: Ulozenie do	pameti a vypis v listingu
		pop	af
		jp	p, test8	; Test osemnbitovej hodnoty na rozsah -256..+255
		ld	a, h

savcod:					; Spracovanie bajtu pri	kompilacii: Ulozenie do	pameti a vypis v listingu
		push	bc
		push	de
		push	hl
		push	af
		call	stbyte		; Ulozenie jedneho bajtu do kodu pri kompilacii
		ld	de, lst_limit
		ld	hl, (plist)
		ld	a, l
		sub	e
		ld	a, h
		sbc	a, d
		jr	c, sc1
		call	outcod		; Vytvorenie riadku pre	listing
		ld	hl, lst_data

sc1:
		pop	af
		call	bnhx		; Prevod 8bit hodnoty na hexadecimalne cislo
		ld	(plist), hl
		pop	hl
		pop	de
		pop	bc
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

outval:					; Zobrazenie navestia a	jeho hodnoty
		push	hl
		push	de
		inc	hl
		inc	hl
		inc	hl
		bit	7, (hl)
		inc	hl
		inc	hl
		inc	hl
		ld	e, (hl)
		inc	hl
		ld	d, (hl)
		pop	hl
		jr	z, ova2
		ld	b, 4

ova1:
		ld	(hl), 58h ; 'X'
		inc	hl
		djnz	ova1

ova2:					; Prevod 16bit hodnoty na hexadecimalne	cislo
		call	z, bnhx2
		ld	de, -0Bh
		add	hl, de
		ex	de, hl
		pop	hl

outnam_lib:				; Prekopiruje navestie do textoveho buffera
		xor	a
		ld	(iunpln), a
		push	hl
		ld	b, 6

on1:
		ld	a, (hl)
		and	7Fh ; ''
		ld	(de), a
		inc	de
		inc	hl
		djnz	on1
		ld	a, 20h ; ' '
		ld	(de), a
		pop	hl
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

outna0:					; Vypis	navestia - mena	modulu
		ld	de, buffer
		push	de
		call	outnam_lib	; Prekopiruje navestie do textoveho buffera
		pop	hl
		ld	b, 5
		jr	oc2_1		; Vypis	jedneho	riadku listingu

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

outcod:					; Vytvorenie riadku pre	listing
		ld	hl, iunpln
		xor	a
		cp	(hl)
		call	z, blank	; Zmazanie textoveho buffera
		jr	z, oc1
		ld	(hl), a
		ld	hl, (linn)
		inc	hl
		ld	(linn),	hl
		ld	b, h
		ld	c, l
		ld	hl, lst_riadok
		call	bndc		; Prevod 16bit hodnoty na desiatkove cislo

oc1:					; Textovy buffer pre jeden riadok na obrazovke
		ld	hl, buffer
		ld	a, (hl)
		cp	2Ah ; '*'
		call	z, analax	; Vyhodnotenie riadku zacinajuceho hviezdickou
		ld	a, (lst_chyba)
		cp	20h ; ' '

lind:					; Skok pre vypis listingu: 0x04	= vsetko, 0x30 = iba chybne riadky
		jr	z, errln
		ld	hl, errcnt	; Pocet	chyb pri preklade
		inc	(hl)

errln:					; Hladanie konca textu v textovom bufferi
		call	chblk
		ld	b, l
		ld	hl, listing_print

scrlp:					; Znak pre vypis listingu (0x0D	= obrazovka, 0x20 = tlaciaren)
		ld	a, 0
		ld	(lst_eol), a

oc2:
		inc	hl

oc2_1:					; Vypis	jedneho	riadku listingu
		ld	a, (hl)
		call	opschr		; Vypis	jedneho	znaku pre vypis	listingu na obrazovke alebo tlaciarni
		ld	a, l
		cp	b
		jr	nz, oc2
		call	ocrlf		; Vypis	CR-LF do listingu
		ld	a, (page)	; Pocitadlo pre	pocet riadkov na jednu stranku listingu	(0 = bez stran)
		or	a
		jr	z, bbc		; Zmazanie casti buffera pre cislo editovaneho riadku
		dec	a
		jr	nz, pg1
		ld	a, 0Ch
		call	opschr		; Vypis	jedneho	znaku pre vypis	listingu na obrazovke alebo tlaciarni
		ld	a, (newpag)	; Pocet	riadkov	na jednu stranu	listingu zadany	pomocou	direktivy *p

pg1:					; Pocitadlo pre	pocet riadkov na jednu stranku listingu	(0 = bez stran)
		ld	(page),	a

bbc:					; Zmazanie casti buffera pre cislo editovaneho riadku
		ld	hl, lst_adresa
		ld	(plist), hl
		ld	hl, lst_riadok

bbc1:
		ld	(hl), 20h ; ' '
		inc	l
		jr	nz, bbc1
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

ocrlf:					; Vypis	CR-LF do listingu
		ld	a, 0Dh
		call	opschr		; Vypis	jedneho	znaku pre vypis	listingu na obrazovke alebo tlaciarni
		ld	a, 0Ah
		jp	opschr		; Vypis	jedneho	znaku pre vypis	listingu na obrazovke alebo tlaciarni

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

get8vl:					; Ziskanie 8-bitovej hodnoty zo	zdrojoveho textu
		call	getval

test8:					; Test osemnbitovej hodnoty na rozsah -256..+255
		ld	a, h
		inc	a
		ret	z
		dec	a
		ret	z

rngerr:
		ld	a, 52h ; 'R'
		jr	seterr

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

asmpsi:					; Kompilacia pseudoinstrukcii s	viac parametrami
		push	af
		call	apsi		; Kompilacia pseudoinstrukcii
		pop	af
		sub	8
		jp	m, asmpsi	; Kompilacia pseudoinstrukcii s	viac parametrami
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

apsi:					; Kompilacia pseudoinstrukcii
		and	7
		sub	2
		jr	c, aexten
		jr	z, adb
		sub	2
		jp	c, asmexp
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

adb:
		ld	a, (de)
		or	a
		jp	p, asmexp
		ld	c, a

savstr:
		dec	de
		dec	c
		ret	p
		ld	a, (de)
		call	savcod		; Spracovanie bajtu pri	kompilacii: Ulozenie do	pameti a vypis v listingu
		jr	savstr

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

aexten:
		inc	a
		ld	a, (de)
		dec	de
		ld	c, a
		jp	z, putsvl	; Zadefinuje label na zadanu hodnotu (s	osetrenim duplicitnych definicii)
		call	vstoax		; Adresa labelu	 (In: C=cislo labelu  Out: HL=adresa labelu)
		bit	7, (hl)
		inc	hl
		jr	z, ae10
		bit	7, (hl)
		jr	nz, ae0
		inc	hl
		bit	7, (hl)
		jr	nz, ae1
		dec	hl
		push	hl
		dec	hl
		push	de
		call	schent		; Vyhladanie vstupneho bodu v kniznici
		pop	de
		pop	hl
		set	7, (hl)

ae0:
		ld	c, 4Dh ; 'M'
		jr	nz, ae2
		res	7, (hl)
		inc	hl
		inc	hl
		inc	hl
		set	7, (hl)
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

ae10:
		inc	hl
		set	7, (hl)

ae1:
		ld	c, 55h ; 'U'

ae2:
		ld	a, c

seterr:
		ld	(lst_chyba), a
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

getval:					; Vyhodnotenie hodnoty vyrazu v	zdrojovom texte	 - v pripade chyby vrati nulu
		call	gvmain
		ld	a, (lst_chyba)
		cp	20h ; ' '
		ret	z
		ld	hl, 0
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

gvmain:					; Vyhodnotenie hodnoty vyrazu v	zdrojovom texte
		ld	a, (de)
		dec	de
		push	af
		add	a, a
		call	getmem_lib	; Vyhodnotenie jednej hodnoty v	zdrojovom texte
		pop	af
		push	bc
		ld	c, a
		rrca
		rrca
		ld	b, a
		and	7
		jr	z, unary
		push	af
		ld	a, b
		call	getmem_lib	; Vyhodnotenie jednej hodnoty v	zdrojovom texte
		pop	af
		pop	hl
		ld	de, optab_2
		jp	pgcnt		; Skok na adresu ulozenu v N-tej polozke v tabulke (A =	index polozky)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

unary:
		ld	a, c
		and	3
		pop	hl
		ret	z
		dec	a
		jr	nz, gv1_b
		ld	l, h

gv1_b:
		dec	a
		jr	z, neghl
		ld	h, 0
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

neghl:
		ld	b, h
		ld	c, l
		ld	h, a
		ld	l, a

op_sub:
		or	a
		sbc	hl, bc
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

op_add:
		add	hl, bc
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

op_mul:
		ex	de, hl
		ld	hl, 0

mullop:
		ld	a, b
		or	c
		ret	z
		add	hl, de
		dec	bc
		jr	mullop

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

op_div:
		ld	a, b
		or	c
		ld	a, 5Ah ; 'Z'
		jr	z, seterr
		ld	de, 0

divlop:
		or	a
		sbc	hl, bc
		inc	de
		jr	nc, divlop
		dec	de
		ex	de, hl
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

op_and:
		ld	a, h
		and	b
		ld	h, a
		ld	a, l
		and	c
		ld	l, a
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

op_or:
		ld	a, h
		or	b
		ld	h, a
		ld	a, l
		or	c
		ld	l, a
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

op_xor:
		ld	a, h
		xor	b
		ld	h, a
		ld	a, l
		xor	c

optab_2:
		ld	l, a
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

		dw op_add		; Tabulka operatorov vo	vyrazoch v zdrojovom texte
		dw op_sub
		dw op_mul
		dw op_div
		dw op_and
		dw op_or
		dw op_xor

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

getmem_lib:				; Vyhodnotenie jednej hodnoty v	zdrojovom texte
		add	a, a
		ex	de, hl
		ld	c, (hl)
		dec	hl
		jr	nc, gm1
		ld	b, (hl)
		dec	hl
		ex	de, hl
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

gm1:
		ld	b, 0
		ex	de, hl
		ret	p
		ld	(exaf),	a
		xor	a
		or	c
		jr	nz, notpc
		ld	bc, (curpc)	; Adresa zadana	ORG-om kde bude	kompilovany kod	fungovat
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

notpc:					; Adresa labelu	 (In: C=cislo labelu  Out: HL=adresa labelu)
		call	vstoax
		ld	a, (hl)
		inc	hl
		rla
		ld	a, (hl)
		rla
		inc	hl
		ld	c, 44h ; 'D'
		jp	c, ae2
		rrca
		cpl
		and	80h ; ''
		or	(hl)
		ld	(hl), a
		jp	m, ae1
		inc	hl
		ld	a, (hl)
		rla
		inc	hl
		inc	hl
		inc	hl
		ld	c, (hl)
		inc	hl
		ld	b, (hl)
		ret	nc
		ld	a, (exaf)
		add	a, a
		ld	a, 45h ; 'E'
		jp	nz, seterr
		ld	a, (pcode+1)	; Adresa zadana	ORG-om alebo direktivou	*c kam sa bude ukladat kod
		ld	(hl), a
		dec	hl
		ld	a, (pcode)	; Adresa zadana	ORG-om alebo direktivou	*c kam sa bude ukladat kod
		ld	(hl), a
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

newpc:					; Urcenie adresy nasledujucej instrukcie
		ld	a, (de)
		cp	0FEh ; ''
		ret	nc
		dec	de
		rrca
		jr	c, npps
		ld	b, 7

npil:
		rra
		jr	nc, npi1
		inc	hl

npi1:
		dec	b
		jr	nz, npil
		inc	hl
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

npps:
		ld	c, a
		and	7
		dec	a
		dec	a
		jr	z, npdb
		dec	a
		jr	z, npdw
		dec	a
		jr	z, nporg
		dec	a
		ret	nz

npds:
		push	hl
		call	getval		; Vyhodnotenie hodnoty vyrazu v	zdrojovom texte	 - v pripade chyby vrati nulu
		push	hl
		ld	bc, (pcode)	; Adresa zadana	ORG-om alebo direktivou	*c kam sa bude ukladat kod
		ld	a, b
		or	c
		jr	z, npds1
		add	hl, bc
		ld	(pcode), hl	; Adresa zadana	ORG-om alebo direktivou	*c kam sa bude ukladat kod

npds1:
		pop	hl
		pop	bc
		add	hl, bc
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

nporg:					; Vyhodnotenie hodnoty vyrazu v	zdrojovom texte	 - v pripade chyby vrati nulu
		call	getval
		ld	(pcode), hl	; Adresa zadana	ORG-om alebo direktivou	*c kam sa bude ukladat kod
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

npdb:
		ld	a, (de)
		dec	de
		or	a
		jp	m, npstp
		dec	de
		inc	hl
		add	a, a
		jp	p, npdb1
		dec	de

npdb1:
		and	3Ch ; '<'
		cp	8
		jr	c, npdbc
		dec	de
		and	4
		jr	z, npdbc
		dec	de
		jr	npdbc

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

npstp:
		and	7Fh ; ''
		push	bc
		ld	c, a
		ld	b, 0
		ex	de, hl
		or	a
		sbc	hl, bc
		ex	de, hl
		add	hl, bc
		pop	bc

npdbc:
		ld	a, c
		sub	8
		ret	p
		ld	c, a
		jr	npdb

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

npdw:
		ld	a, c
		rra
		rra
		and	1Eh
		add	a, 2
		ld	c, a
		ld	b, 0
		add	hl, bc
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

symtab:					; Skok pre vypis listingu: 0x04	= vsetko, 0x30 = iba chybne riadky
		ld	a, (lind+1)

symtab_3:
		cp	4
		ret	nz
		ld	hl, (adstab)	; Adresa tabulky navesti
		ld	c, (hl)
		inc	c

sfs:
		dec	c
		ret	z
		call	vstoas		; Adresa labelu	 (In: C=cislo labelu  Out: DE=adresa labelu)
		ld	a, (de)
		or	a
		jp	p, sfs
		call	clrd		; Zmazanie textoveho buffera
		inc	hl

loopi:
		ld	de, symtab_3
		ld	bc, (adstab)	; Adresa tabulky navesti
		ld	a, (bc)
		ld	c, a
		inc	c
		ex	de, hl
		push	de
		push	hl

loopj:
		push	hl

loopj_1:
		dec	c
		jr	z, endj
		call	vstoas		; Adresa labelu	 (In: C=cislo labelu  Out: DE=adresa labelu)
		ld	a, (de)
		or	a
		jp	p, loopj_1
		push	de
		inc	de
		inc	de
		inc	de
		inc	de
		inc	de
		ld	a, (de)
		pop	de
		rlca
		jr	c, loopj_1
		pop	hl
		call	cmpsym		; Porovnanie dvoch navesti ci sa jedna o to iste navestie
		jr	c, loopj
		push	de
		jr	loopj_1

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

endj:
		pop	hl
		pop	de
		call	cmhlde		; Porovnanie HL	a DE
		pop	de
		jr	z, endi
		ld	a, e
		add	a, 7
		cp	39h ; '9'
		jr	c, cst
		push	hl
		ld	hl, buffer	; Textovy buffer pre jeden riadok na obrazovke
		ld	b, 3Eh ; '>'
		call	oc2_1		; Vypis	jedneho	riadku listingu
		call	clrd		; Zmazanie textoveho buffera
		pop	de
		ex	de, hl
		ld	a, 8

cst:
		ld	e, a
		call	outval		; Zobrazenie navestia a	jeho hodnoty
		inc	hl
		inc	hl
		inc	hl
		inc	hl
		inc	hl
		set	7, (hl)
		ld	a, e
		add	a, 7
		ld	e, a
		ex	de, hl
		ld	(hl), 2Ah ; '*'
		inc	hl
		inc	hl
		inc	hl
		jr	loopi

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

endi:					; Textovy buffer pre jeden riadok na obrazovke
		ld	hl, buffer
		ld	b, 3Eh ; '>'
		jp	oc2_1		; Vypis	jedneho	riadku listingu

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

lnk:					; Prikaz mrs>lnk - linkovanie zdrojoveho textu
		ld	bc, ilnli

lnk1:					; call ilnli - Inicializacia obrazovky a vypisovej rutinky pre listing
		ld	(lnk2+1), bc

lnk2:					; call ilnli - Inicializacia obrazovky a vypisovej rutinky pre listing
		call	rom_0
		ld	hl, tude	; Vypis	"Undefined externals:"
		ld	b, 0C1h	; ''
		call	oc2_1		; Vypis	jedneho	riadku listingu
		ld	de, libbeg	; Zaciatok kniznice a napis "sysmod"
		call	gext1		; Vyhladanie tabulky navesti EXT v moduloch kniznice

cext:
		jp	z, erryi
		push	de
		push	hl
		ld	de, libbeg	; Zaciatok kniznice a napis "sysmod"
		call	gent1		; Vyhladanie tabulky navesti ENT v moduloch kniznice

cent:
		push	de
		pop	de
		pop	de
		push	de
		dec	sp
		dec	sp
		ld	b, 6

lk3:
		ld	a, (de)
		cp	(hl)
		jr	nz, gent
		inc	hl
		inc	de
		djnz	lk3
		ld	a, (de)
		ld	b, a
		inc	de
		ld	a, (hl)
		inc	hl
		ld	h, (hl)
		ld	l, a
		ex	de, hl

lk4:
		dec	b
		inc	sp
		inc	sp
		jp	m, nxtext
		dec	sp
		dec	sp
		ld	a, (hl)
		inc	hl
		push	hl
		ld	h, (hl)
		ld	l, a
		ld	(hl), e
		inc	hl
		ld	(hl), d
		pop	hl
		inc	hl
		jr	lk4

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

gent:
		pop	de
		call	gentnm
		jr	nz, cent
		pop	hl
		push	hl
		call	outna0		; Vypis	navestia - mena	modulu
		ld	hl, errcnt	; Pocet	chyb pri preklade
		inc	(hl)

nxtext:
		pop	hl
		pop	de
		call	gextnm
		jr	cext

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

illa:					; Zmaze	obrazovku, nastavi kurzor vlavo	dole a vynuluje	pocet chyb
		call	clear
		ld	hl, 1600h
		ld	(cursor), hl	; Aktualna pozicia vypisu. Prvy	bajt je	stlpec 0-31, druhy bajt	je riadok 0-23.
		ld	h, 0
		ld	(errcnt), hl	; Pocet	chyb pri preklade
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

ilnli:					; Inicializacia	obrazovky a vypisovej rutinky pre listing
		call	illa

ilnli1:
		ld	a, 4
		ld	(lind+1), a	; Skok pre vypis listingu: 0x04	= vsetko, 0x30 = iba chybne riadky
		ld	hl, outchr	; Vypis	jedneho	znaku na obrazovku
		ld	(opsch3+1), hl	; Volanie rutinky pre vypis jedneho znaku listingu (outchr = obrazovka,	pntchr = tlaciaren)
		ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

lstlib:					; Prikaz lib>lst - Vypis modulov kniznice
		call	ilnli
		ld	de, libbeg	; Zaciatok kniznice a napis "sysmod"

lb1:
		push	de
		push	de
		ex	de, hl
		call	outna0		; Vypis	navestia - mena	modulu
		call	outcrl		; Presun kurzora na zaciatok noveho riadku
		pop	de
		call	gaexen		; Zisti	pocet navesti v	danom module kniznice (DE = adresa modulu)
		jr	z, lb3

lb2:
		dec	a
		jp	m, lb3
		push	af
		push	hl
		ld	de, buffer_instr
		call	outval		; Zobrazenie navestia a	jeho hodnoty
		ld	hl, buffer	; Textovy buffer pre jeden riadok na obrazovke
		ld	b, 0Ah
		call	oc2_1		; Vypis	jedneho	riadku listingu
		pop	hl
		pop	af
		ld	de, 8
		add	hl, de
		jr	lb2

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

lb3:					; Presun kurzora na zaciatok noveho riadku
		call	outcrl
		pop	de
		call	gmodnm		; Zisti	hodnotu	navestia a porovna so zaciatkom	volnej pamete
		jr	nz, lb1
		jr	lib		; Prikaz mrs>lib - skok	do modulu lib>

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

delmod:					; Prikaz lib>del - Zmazanie posledneho modulu kniznice
		ld	de, libbeg
		call	gmodnm		; Zisti	hodnotu	navestia a porovna so zaciatkom	volnej pamete
		jr	z, lib		; Prikaz mrs>lib - skok	do modulu lib>

dm1:
		push	de
		call	gmodnm		; Zisti	hodnotu	navestia a porovna so zaciatkom	volnej pamete
		pop	hl
		jr	nz, dm1
		ld	(libtop), hl	; Koniec kniznice a zaciatok volnej pamete
		ld	(memory), hl	; Koniec kniznice a zaciatok volnej pamete

;;;;;;;;;;;;;;;;;;;;
;;		  ;;
;;  Modul "lib>"  ;;
;;		  ;;
;;;;;;;;;;;;;;;;;;;;

lib:					; Prikaz mrs>lib - skok	do modulu lib>
		ld	hl, tlib
		ld	de, clib
		jp	ctrl

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

loalib:					; Prikaz lib>loa - Nacitanie kniznice s	pasky
		xor	a
		ld	hl, lib		; Prikaz mrs>lib - skok	do modulu lib>
		call	load
		jr	lib		; Prikaz mrs>lib - skok	do modulu lib>

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

savlib:					; Prikaz lib>sav - Ulozenie kniznice na	pasku
		ld	de, sysmod
		ld	hl, (libtop)	; Koniec kniznice a zaciatok volnej pamete
		ld	(memory), hl	; Koniec kniznice a zaciatok volnej pamete
		ld	bc, lib		; Prikaz mrs>lib - skok	do modulu lib>
		xor	a
		jp	save

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

entry:					; Prikaz lib>ent - Oznacenie vstupneho bodu pre	spustenie programu v kniznici
		ld	a, (de)
		ex	de, hl
		ld	de, 52h	; 'R'
		or	a
		jr	z, ent1
		cp	20h ; ' '
		jp	nz, mrs2	; Oprava textu zadaneho	v module "mrs"
		inc	hl
		call	schent		; Vyhladanie vstupneho bodu v kniznici
		jp	z, mrs2		; Oprava textu zadaneho	v module "mrs"
		ld	de, 6
		add	hl, de
		ld	e, (hl)
		inc	hl
		ld	d, (hl)

ent1:					; Entry	point do skompilovaneho	programu
		ld	(sysmod+1), de
		jr	lib		; Prikaz mrs>lib - skok	do modulu lib>

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

    OUTEND

    EMPTYTAP tap_file
    SAVETAP  tap_file ,	BASIC ,	"mrs"     , basic  , basend-basic  , 0
    SAVETAP  tap_file ,	 CODE ,	"mrs.V01" , tmf    , endcod-tmf
    SAVETAP  tap_file ,	 CODE ,	"sysmod"  , sysmod , fremem-sysmod , sysmod , 0

endcod:		ds 1
		ds 1
		ds 1
		ds 1
		ds 1
		ds 1
		ds 1
		ds 1
		ds 1
		ds 1
		ds 1
		ds 1
		ds 1
listing_print:	ds 1
lst_riadok:	ds 1
		ds 1
		ds 1
		ds 1
		ds 1
lst_chyba:	ds 1
		ds 1
lst_adresa:	ds 1
		ds 1
		ds 1
		ds 1
		ds 1
lst_data:	ds 1
		ds 1
		ds 1
		ds 1
		ds 1
		ds 1
		ds 1
edi_riadok:	ds 1
lst_limit:	ds 1
		ds 1
lst_eol:	ds 1
buffer:		ds 1			; Textovy buffer pre jeden riadok na obrazovke
		ds 1
buffer_2:	ds 1
		ds 1
		ds 1
		ds 1
		ds 1
buffer_instr:	ds 1
buffer_meno:	ds 1
		ds 1
		ds 1
		ds 1
buffer_params:	ds 1
		ds 1
		ds 1
		ds 1
		ds 1
		ds 1
buffer_dlzka:	ds 2
buffer_adresa:	ds 2
		ds 1
		ds 1
		ds 1
		ds 1
		ds 1
		ds 1
		ds 1
		ds 1
		ds 1
		ds 1
buffer_comment:	ds 1
		ds 1
		ds 1
		ds 1
		ds 1
		ds 1
		ds 1
		ds 1
		ds 1
		ds 1
		ds 1
		ds 1
		ds 1
		ds 1
		ds 1
		ds 1
		ds 1
		ds 1
		ds 1
		ds 1
		ds 1
		ds 1
		ds 1
		ds 1
		ds 1
		ds 1
		ds 1
		ds 1
		ds 1
		ds 1
		ds 1
buffer_end:	ds 1
sent:		ds 2
cursor:		ds 1			; Aktualna pozicia vypisu. Prvy	bajt je	stlpec 0-31, druhy bajt	je riadok 0-23.
row:		ds 1
poscur:		ds 2			; Aktualna pohoha blikajuceho atributu na obrazovke
krept:		ds 2
		ds 48h
pdline:		ds 70h			; Buffer pre spakovany riadok zdrojoveho textu
		ds 40h
stack_init:	ds 0C0h
; end of 'RAM'

		end
